[{"categories":["后端"],"content":" 前言：JVM就是我们平时开发经常提到的Java虚拟机（Java Virtual Machine），既然是虚拟机，那他肯定具备真实计算机的功能，只不过不是从硬件层面真实体现。那么JVM具体包含些什么？本文通过一个示例作出解析。\n 一，结构图我先标在这里，方便有个整体的记忆。 二，写一个简单的例子\n1public class Test { 2 //计算 3 public int calc(){ 4 int a = 1; //第三处代码 5 int b = 2;\t//第四处代码 6 int c = a + b;\t//第五处代码 7 return c;\t//第六处代码 8 } 9\t//主程序 10 public static void main(String[] args) { 11 Test test = new Test(); //第一处代码 12 test.calc(); //第二处代码 13 } 14} 三，我们开始运行程序\n当我们运行main方法时，就生成了一个main主线程，线程实际就会存入到栈里面，那栈里面有什么呢？现在我们放大Thread main线程看看 这里有点套娃，线程里面包含有三块：程序计数器，线程栈，本地方法栈。\n程序计数器：主要是用来记录当前线程代码的执行位置，用于CPU切换线程再回来时能够继续执行。所以计数据器是每个线程所独有的，假定当前已执行到第一处代码，计数器标记为1。\n本地方栈：这个好理解主要是替我们执行Native方法。\n线程栈：采用先进后出（FILO）的方式存储栈帧。那什么是栈帧呢？我们可以把类里面的每个方法就理解成栈帧。上图我只画了main方法的栈帧，接下来我们执行第二处代码，把cal()方法也压入栈。 可以看到cal栈帧里面包含四个部份： 局部变量：如cal里面定义的变量a，b，c，他们是相对于栈帧进行隔离的，存放在这个区域。 操作数栈：随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。当我们运行第三，四，五行代码的时候，这里实际就是将1，2两个数压入操作数栈中，当cpu进行相加操作完成后再将数3出栈返回给c。 我们可以在Test.class目录用javap命令查看指令逻辑\n javap -c Test.class\n 1 public int calc(); 2 Code: 3 0: iconst_1 //将int类型常量1压入操作数栈 4 1: istore_1\t// 将int类型值存入局部变量1 5 2: iconst_2 6 3: istore_2 7 4: iload_1\t//从局部变量1中装载int类型值 8 5: iload_2 9 6: iadd\t//执行int类型的加法 10 7: istore_3 11 8: iload_3 12 9: ireturn\t//从方法中返回int类型的数据 动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接 方法出口：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。\n好了说完栈，我们聊下堆，我们都知道，像我们第一行代码new Test();，实际这个对象就存储在堆中，要知道java作为高级语言，我们是有垃圾回收机制自动帮我们回收无用的对象的，也就是我们平时说的GC。这期我们不展开讲GC，只讲下堆里面的各个区间，如下图： 堆可以分为两代：年轻代和老年代 年轻代可以分为：Eden区，Survivor To，Survivor From 我们生成的对象大部份都是朝生夕死的，所以一般会存放到年轻代的Eden区，当成为垃圾对象后，gc会对其进行回收，并将余下未回收的对象，存入Survivor From区，并将对象的年龄加一，等到下次gc，会连同Eden区和Survivor From区里面的对象一起回收，并将未回收成功的对象放入Survivor To区，并继续将年龄加一，依次往复，当对象年龄超过15次（默认），会将对象移到老年代，老年代了咋整？放心老年代也会gc的，只不过方式不太一样。\n最后还剩下方法区：方法区主要存放我们的类信息，常量和静态变量，所以这块区域是公有的。  总结：今天算是对JVM总体结构有一个比较深刻的认识。学习还是要知其然知其所以然，我是阿雷，一个没秃顶的程序员。\n ","date":"2021-06-03","img":"","permalink":"/zh-cn/posts/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/","series":["Java"],"tags":["jvm"],"title":"JVM内存结构详解"},{"categories":["后端"],"content":" 前言：各位码友，今天不说技术，聊聊最近比较火的两个词，内卷和躺平。\n 内卷和躺平啥意思？\n 内卷：本意是指人类社会在一个发展阶段达到某种确定的形式后，停滞不前或无法转化为另一种高级模式的现象。 当社会资源无法满足所有人的需求时，人们通过竞争来获取更多资源。 经网络流传，很多高等学校学生用其来指代非理性的内部竞争或“被自愿”竞争。（源自百度百科）\n  躺平：指无论对方做出什么反应，你内心都毫无波澜，对此不会有任何反应或者反抗，表示顺从心理。另外在部分语境总表示为：瘫倒在地，不再鸡血沸腾、渴求成功了。（源自百度百科）\n 噢，到底啥意思？\n一天，阿雷隔壁同事小明中午吃了桶泡面，吃得那叫一个香，惹得阿雷非常羡慕，馋得不行。于是第二天，我也吃了一桶泡面，小明见到了我在吃，心想：\n“哟呵，你也吃泡面？还跟我吃一样的，不行，我得吃得比你好”。于是小明就吃了一桶老坛酸菜面。\n我一见还得了：“你吃酸菜的了不起啊，我得搞桶麻辣牛肉的”。\n小明：“那我吃豪华卤香牛肉的”。\n我：“那我吃两桶”。\n小明：“我吃三桶，比你多”。\n于是就这样不停加码，反复地你大我，我压你。（有卷那味了~） 。。。\n终于有一天，小明累了，要 quit，要躺平。\ntoo young ,too simple 你以为躺平就完事啦？躺平也能卷。\n阿雷一瞧，你躺？我也躺。\n你晚上十一点躺，我就晚上十点躺；\n你躺地上，我躺床上；\n你躺着开风扇，我就躺着开空调；\n你躺在小区里，我就躺在别野里；\n你躺着坐公交，我就躺着坐小车。\n那我躺着不动总行吧？\n那不行，我也躺着不动，眼睛都不带眨的，你要是连心跳都没有我就算你赢。\n当然这是玩笑话。 不过这俗话说得好，有人的地方就有江湖。卷这个问题我想大概率是杜绝不了的，但如果能把它好好运作，形成良性竞争的话，这样也许就成就你好，我好，大家好的局面。况且，资本那灵敏的鼻子总是不停地在嗅探着市场，人人都躺平了，我估计什么“躺平经济”也要应运而生了。\n最后作为一个95后，我觉得大伙嚷嚷着说要躺平，只不过是平时面对压力的一种宣泄，说完了，还是得照常上班，努力搬砖，顺便有时还会点个赞，您说是吧？\n我是阿雷，一个恍恍惚惚的程序员。\n","date":"2021-06-02","img":"","permalink":"/zh-cn/posts/%E5%81%87%E5%A6%82%E8%BA%BA%E5%B9%B3%E4%B9%9F%E5%BC%80%E5%A7%8B%E5%86%85%E5%8D%B7/","series":["开心一下"],"tags":["躺平"],"title":"假如躺平也开始内卷。。。"},{"categories":["后端"],"content":" 前言：铁汁们，今天又是代码被虐爆肝的一天，被啥虐了嘞，看标题就知道了，话不多说上代码。\n 1public class StringInternTest { 2 3 public static void main(String[] args) { 4 5 String s1 = \u0026#34;1\u0026#34;; 6 String s= new String(\u0026#34;1\u0026#34;); 7 s.intern(); 8 System.out.println(s == s1); 9 10 String s3 = new String(\u0026#34;a\u0026#34;) + new String(\u0026#34;b\u0026#34;); 11 s3.intern(); 12 String s4 = \u0026#34;ab\u0026#34;; 13 System.out.println(s3 == s4); 14 15 } 16} 运行结果是这样： 起初我觉得不可思议，两串差不多的代码，运行结果却是截然相反，而且 在我的印象里，String类型的数据判断是否相等要用equals方法，定义两个String类型的变量用==号判断结果为true我还是头一次见到，真是越学越放弃。所以不懂就要问度娘：\n Java为了提高性能，对基本数据类型和String类型提供了常量池的概念，相当于就是做了缓存处理了。 对于String类型数据：\n 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的对象，可用使用String的intern方法。intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。   啥意思？ 先看下s和s1 结果同我预想的一样，s1指向的是常量的地址，s是指向堆中的地址，二都不相等，结果为false。 再来看下s3和s4： 但是不对啊，我s3还是指向的堆里面的地址，s4是指向的常量池里面的地址，这不还是一样不相等吗？ 纠结了很久才找到答案：\n JDK7之前确实是这样，直接复制一个字符串放到常量池中，而在JDK7之后，常量池就放进堆里面一起存放了，所以不需要再复制对象而是直接添加对象的引用到常量池就可以了。\n 所以最终图可以这么画： 我是阿雷，我在秃头的路上等着你。\n","date":"2021-06-01","img":"","permalink":"/zh-cn/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84string%E5%92%8Cinternal%E7%BB%88%E4%BA%8E%E6%83%B3%E9%80%9A%E4%BA%86/","series":["Java"],"tags":["String"],"title":"搞了一天的String和internal，终于想通了"},{"categories":["后端"],"content":" 前言：看到Java和Python的相爱相杀，我脑补出了一部后宫争斗大戏（无语言歧视，只是娱乐，皮一下各位看官请轻喷~）。\n 演员表(角色按排名分配)    语言 角色     C 皇后   Python 贵妃   Java 贵妃   C++ 贵妃   C# 妃   PHP 嫔   其他 群演    后宫月度总结大会进行中\u0026hellip; C皇后：  各位妹妹，这月末总结又到了，各位的KPI也都出来了，表现得怎么样，大伙都说说吧。（凭老娘的位份，都懒得瞅你们）。\n Python贵妃：  （抢着开口）C姐姐，都是妹妹的错，本月竟然超过Java姐姐得了第二，内心惶恐不安，怕惹怒了Java姐姐，扰得后宫不宁，Java姐姐，妹妹只是无心之失，姐姐不会怪妹妹吧。（非常茶的口吻）\n Java贵妃：  （哼，兼任就是矫情，看老娘怎么怼你）妹妹说的哪里话，都是自家姐妹，说什么怪不怪的。况且妹妹正得盛宠，业绩高些也是应该得。（小样，得宠又怎么样，还不是只比老娘高那么一点点，老娘家大业大，怕你这点业绩？）\n C++贵妃：  回C姐姐的话，妹妹能有今日地位，多亏C姐姐平日的照拂，在宫里有自家的姐妹真好，妹妹但愿与世无争，与众位姐妹和平共处。（脸上笑嘻嘻，心里MMP）。\n C#妃：  （呵呵。老娘不出声，看着你们斗。同样都姓C，一个当皇后，一个是贵妃，老娘混了这么久却还只是个妃位，我好恨。想当年我也荣耀过，当年跟Java这个兼任平起平坐的时候，你Python连个P都还没有，要不是母家不给力，现在还有你们说话的份？）\n PHP嫔：  （岔开话题）各位姐姐，容妹妹说一句，这KPI固然重要，但也要注意保养，尤其是我们女人，到时千万别因为芝麻，丢了西瓜。你们说是不是啊姐姐们。（呵呵，老娘是世界上最好的，皇上不来看我，定是被你们这起子狐媚子迷了眼，只要皇上看到我，就肯定不会再忘记我。）\n C皇后：  P嫔的话倒是有几分道理，大伙都要跟P嫔好好学学，免得到时候在皇上面前错了主意，惹得皇上不高兴批评了你们，再让本宫知道了那可就不是批评这么简单了,你说是吧，P嫔。好了，本宫也累了，今天就先到这吧，大伙都散了吧。(竟然说要老娘注意保养，我呵呵哒。)\n 阿雷想请问下各位目前用了哪些语言呢？如果真有这后宫情景，他们又会说些啥想些啥呢？图个乐~\n","date":"2021-05-31","img":"","permalink":"/zh-cn/posts/5%E6%9C%88%E6%94%B6%E5%AE%98%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E5%90%8D%E7%9A%84%E5%90%8E%E5%AE%AB%E5%A4%A7%E6%88%8F/","series":["语言"],"tags":[],"title":"5月收官，编程语言排名的后宫大戏"},{"categories":["后端"],"content":" 前言： 现如今，电话是接外卖和快递的，短信是用来收验证码的。那么像一般的App里面使用手机号+验证码方式进行注册或登录是怎样实现的呢？这篇文章可能帮到你。\n 1.寻找合适的短信平台 因为三大运营商的限制摆在那里，凭个人力量当然是不太可能直接发送短信给到用户。所以我们只好依托强大的平台来做后盾。像阿里云，腾讯云等都有提供短信通知服务，虽然平台众多，但实现方式大体相同。此处以阿里云短信为例。\n2.注册阿里云账号（已有账号可跳过） 使用钉钉，淘宝或支付宝扫码注册均可，链接如下，进入后点击右上角注册按钮跳转注册页面：\n https://cn.aliyun.com/\r 3.开通短信服务，购买短信套餐包 购买地址: 点击跳转\r如果链接失效，可以在阿里云首页搜索短信服务，点击后再点立即购买即可跳转，截图如下（如果提示未开通短信服务，只需要确定开通即可）： 4.短信签名和短信模板申请 购买成功后，点击首页的控制台进入，如果找不到短信入口，可以在产品服务里面搜索到，截图如下，这样就进入控制台啦： 5.添加短信签名与模板（国内消息）  签名（点击添加按钮，填写相应资料，保存等待审核即可） 签名指的是短信内容里面中括号【】包含的文本，用作发送方身份标识。  模板 模板即为短信的正文内容，点击添加模板按钮，填写相关资料提交审核。 模板里面的变量使用${}语法，一个短信里面可以设置多个变量。（模板审核耗时比较长，建议尽早提交审核），当审核完成后即可以拿到templateCode。   6.集成到项目里（maven方式演示，代码已上传github， 点击查看\r）  获取accesskey和secret 查看右上角的头像，点击Accesskey管理，去生成key和秘钥（秘钥只生成一次，要妥善保存好）。此处还可以使用子账号的accessKey进行短信发送，但跟本次内容无关就不再详细说明。  添加maven依赖 注意版本的使用，这这里使用的是4.5.16  1\u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;aliyun-java-sdk-core\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;4.5.16\u0026lt;/version\u0026gt; 5\u0026lt;/dependency\u0026gt; 6 7\u0026lt;dependency\u0026gt; 8\t\u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; 9\t\u0026lt;artifactId\u0026gt;aliyun-java-sdk-dysmsapi\u0026lt;/artifactId\u0026gt; 10\t\u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; 11\u0026lt;/dependency\u0026gt;  测试发送代码（springboot结合)  1@Value(\u0026#34;${signName}\u0026#34;) 2private String signName; 3 4@Value(\u0026#34;${templateCode}\u0026#34;) 5private String templateCode; 6 7@Value(\u0026#34;${accessKey}\u0026#34;) 8private String accessKey; 9 10@Value(\u0026#34;${accesssSecret}\u0026#34;) 11private String accesssSecret; 12 13 /** 14 * 发送验证码逻辑 15 */ 16private Map\u0026lt;String,String\u0026gt; sendSms(String mobile) throws ClientException { 17 18 Map\u0026lt;String,String\u0026gt; resultMap = new HashMap\u0026lt;\u0026gt;(); 19 20 //可自助调整超时时间 21 System.setProperty(\u0026#34;sun.net.client.defaultConnectTimeout\u0026#34;, \u0026#34;10000\u0026#34;); 22 System.setProperty(\u0026#34;sun.net.client.defaultReadTimeout\u0026#34;, \u0026#34;10000\u0026#34;); 23 24 //初始化acsClient,暂不支持region化 25 IClientProfile profile = DefaultProfile.getProfile(\u0026#34;cn-hangzhou\u0026#34;, accessKey,accesssSecret); 26 DefaultProfile.addEndpoint(\u0026#34;cn-hangzhou\u0026#34;, \u0026#34;cn-hangzhou\u0026#34;, \u0026#34;Dysmsapi\u0026#34;, \u0026#34;dysmsapi.aliyuncs.com\u0026#34;); 27 IAcsClient acsClient = new DefaultAcsClient(profile); 28 29 //组装请求对象-具体描述见控制台-文档部分内容 30 SendSmsRequest request = new SendSmsRequest(); 31 //必填:待发送手机号 32 request.setPhoneNumbers(mobile); 33 //必填:短信签名-可在短信控制台中找到 34 request.setSignName(signName); 35 request.setTemplateCode(templateCode); 36 37 int rand_num = (int)((Math.random()*9+1)*100000); 38 39 request.setTemplateParam(\u0026#34;{\\\u0026#34;code\\\u0026#34;:\\\u0026#34;\u0026#34;+rand_num+\u0026#34;\\\u0026#34;}\u0026#34;);//此处最好使用转json工具 40 41 //hint 此处可能会抛出异常，注意catch 42 SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); 43 String code = sendSmsResponse.getCode(); 44 if(code.equals(\u0026#34;OK\u0026#34;)){ 45 resultMap.put(\u0026#34;code\u0026#34;,\u0026#34;1000\u0026#34;); 46 resultMap.put(\u0026#34;msg\u0026#34;,\u0026#34;发送成功\u0026#34;); 47 }else{ 48 resultMap.put(\u0026#34;code\u0026#34;,\u0026#34;-1000\u0026#34;); 49 resultMap.put(\u0026#34;msg\u0026#34;,\u0026#34;发送失败\u0026#34;); 50 } 51 52 return resultMap; 53 } 54 1 /** 2 * 程序的入口 3 */ 4@RequestMapping(value=\u0026#34;/sendsms\u0026#34;) 5@ResponseBody 6public Map\u0026lt;String,String\u0026gt; getValidCode(String mobile){ 7 try { 8 return this.sendSms(mobile); 9 } catch (ClientException e) { 10 e.printStackTrace(); 11 } 12 Map\u0026lt;String,String\u0026gt; resultMap = new HashMap\u0026lt;\u0026gt;(); 13 resultMap.put(\u0026#34;code\u0026#34;,\u0026#34;-1000\u0026#34;); 14 resultMap.put(\u0026#34;msg\u0026#34;,\u0026#34;发送失败\u0026#34;); 15 return resultMap; 16}  其他API 请查看短信官方文档。点这\r  7.总结  如上就是项目结合阿里云发送短信验证码的具体实现逻辑了。我们可以结合缓存工具（如redis），实现验证码的有效期，从而进一步实现登录的业务逻辑。流程图如下：\n ","date":"2021-05-30","img":"","permalink":"/zh-cn/posts/app%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/","series":["Java"],"tags":["短信"],"title":"App发送短信验证码实现"},{"categories":["后端"],"content":"1，什么是双亲委派机制？  我的理解是，在java中，当类加载器需要对class文件进行加载时，会递归调用父加载器，当父加载器加载失败时，再向下递归传递进行加载，最后加载成功或失败。（感觉有点绕~）\n 2，类加载器有哪些？ 3，执行流程是怎样的？ 4，优点  1，安全加载：当加载类时，先委托父加载器加载可以避免破坏我们核心包里面的类。如我们可以项目里面建一个java.lang.String的类，但这样运行时实际找到的是Bootstrap ClassLoad加载的核心包里面的String，从而起到保护作用。 2，避免类重复加载：当父加载器已经加载了某类时，子加载器就没必要再加载一次。\n 5，打破双亲委派  创建一个类继承ClassLoader，重写loadClass()方法。 但重写的时候需要注意，核心类文件还是需要向上传递进行加载(loadClass)，只有需要自定义加载器加载的目录才直接加载(findClass);否则会出现Object类找不到异常\n 1 protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { 2 synchronized (getClassLoadingLock(name)) { 3 // First, check if the class has already been loaded 4 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); 5 if (c == null) { 6 // If still not found, then invoke findClass in order 7 // to find the class. 8 long t1 = System.nanoTime(); 9 10 //*********** 判断如果为当前需要当前加载器直接加载的目录，则不再向上传递 11 if(name.startsWith(\u0026#34;com.test\u0026#34;)){ 12 c = findClass(name); 13 }else{ 14 //否则按照向上加载，避免出现Object类未找到异常 15 c = this.getParent().loadClass(name); 16 } 17 //************* 18 19 // this is the defining class loader; record the stats 20 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); 21 sun.misc.PerfCounter.getFindClasses().increment(); 22 } 23 if (resolve) { 24 resolveClass(c); 25 } 26 return c; 27 } 28 } 1public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { 2 MyClassLoader myClassLoader = new MyClassLoader(\u0026#34;D:/test\u0026#34;); 3 Class clazz = myClassLoader.loadClass(\u0026#34;com.test.User\u0026#34;); 4 Object obj = clazz.newInstance(); 5 Method method = clazz.getDeclaredMethod(\u0026#34;study\u0026#34;); 6 method.invoke(obj,null); 7 System.out.println(clazz.getClassLoader().getClass().getName()); 8 9 } ","date":"2021-05-29","img":"","permalink":"/zh-cn/posts/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%AC%94%E8%AE%B0/","series":["Java"],"tags":["类加载机制"],"title":"双亲委派机制笔记"}]