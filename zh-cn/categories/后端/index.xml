<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端 on 老雷的博客</title>
    <link>/zh-cn/categories/%E5%90%8E%E7%AB%AF/</link>
    <description>Recent content in 后端 on 老雷的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © 2020-{year} All Rights Reserved.</copyright>
    <lastBuildDate>Sun, 20 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="/zh-cn/categories/%E5%90%8E%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>编译spring的源码</title>
      <link>/zh-cn/posts/%E7%BC%96%E8%AF%91spring%E7%9A%84%E6%BA%90%E7%A0%81/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E7%BC%96%E8%AF%91spring%E7%9A%84%E6%BA%90%E7%A0%81/</guid>
      <description>前言：对于java开发人员来说，spring是必会的一门框架了，于初学者而言，能熟练使用spring就已经很ok了，但对于一匹老码来说，就须</description>
    </item>
    
    <item>
      <title>JVM常见面试题</title>
      <link>/zh-cn/posts/jvm%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/jvm%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>前言：本节主要复习下之前所讲过的一些知识点，整理出一些面试题，供各位大佬享用。 Java类加载过程 类加载器加载class可以大致分为： 加载 &amp;raquo; 验</description>
    </item>
    
    <item>
      <title>并发收集，三色标记算法</title>
      <link>/zh-cn/posts/%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</guid>
      <description>前言：之前我们讲过CMS收集器的回收过程，有一步骤是并发标记，他会在不停止应用线程的情况下判断是否为垃圾对象。感觉就像是你在家里打扫卫生时，</description>
    </item>
    
    <item>
      <title>Java大头：垃圾收集器（三）</title>
      <link>/zh-cn/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%89/</link>
      <pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%89/</guid>
      <description>前言：Garbage-First收集器主要应用在配备大内存，多核处理器的机器上面。他以高概率满足垃圾收集暂停时间目标，同时在几乎不需要配置的</description>
    </item>
    
    <item>
      <title>Java大头：垃圾收集器（二）</title>
      <link>/zh-cn/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BA%8C/</link>
      <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BA%8C/</guid>
      <description>前言：话接上篇讲了垃圾收集器的几大算法，本篇主要讲对应算法的一些实现。话不多说，先看一张图。 图中主要介绍了目前主流的几款垃圾收集器（图中连线</description>
    </item>
    
    <item>
      <title>Java大头：垃圾收集器（一）</title>
      <link>/zh-cn/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%80/</link>
      <pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%80/</guid>
      <description>前言：万事开头难，先从基础概念讲起吧，老规矩，还是以JDK8版本主讲。 一，垃圾收集算法 复制算法：将内存分为大小相同的两块（运行区域，预留区域</description>
    </item>
    
    <item>
      <title>jstack学习：找出cpu飙升代码</title>
      <link>/zh-cn/posts/jstack%E5%AD%A6%E4%B9%A0%E6%89%BE%E5%87%BAcpu%E9%A3%99%E5%8D%87%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 11 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/jstack%E5%AD%A6%E4%B9%A0%E6%89%BE%E5%87%BAcpu%E9%A3%99%E5%8D%87%E4%BB%A3%E7%A0%81/</guid>
      <description>前言：虽然现在有像arthas这样强大的调优诊断工具，但懂得操作基础命令也是一项永远不会过时的技能。 在某一个漆黑的夜晚，我们努力肝了一个新版</description>
    </item>
    
    <item>
      <title>重识HashMap（三）</title>
      <link>/zh-cn/posts/%E9%87%8D%E8%AF%86hashmap%E4%B8%89/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E9%87%8D%E8%AF%86hashmap%E4%B8%89/</guid>
      <description>面试官：HashMap多线程安全么？不安全，为啥不安全？ 上一期我们看了HashMap#put方法的执行过程，通过源码很容易找出个答案回怼面试</description>
    </item>
    
    <item>
      <title>重识HashMap（二）</title>
      <link>/zh-cn/posts/%E9%87%8D%E8%AF%86hashmap%E4%BA%8C/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E9%87%8D%E8%AF%86hashmap%E4%BA%8C/</guid>
      <description>前言：没想到短短的一个put方法，竟然有这么多逻辑。。。 Hello，昨天大概讲了下HashMap中几个重要的默认值以及HashMap的构造函</description>
    </item>
    
    <item>
      <title>重识HashMap（一）</title>
      <link>/zh-cn/posts/%E9%87%8D%E8%AF%86hashmap%E4%B8%80/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E9%87%8D%E8%AF%86hashmap%E4%B8%80/</guid>
      <description>前言：当我意识到我对HashMap的了解还停留在键值对，线程不安全的时，我心里咯噔了一下，我想是时候重新认识一下他，希望这种觉悟还不太晚。 不</description>
    </item>
    
    <item>
      <title>理解下栈上分配机制</title>
      <link>/zh-cn/posts/%E7%90%86%E8%A7%A3%E4%B8%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E7%90%86%E8%A7%A3%E4%B8%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</guid>
      <description>我们一般认为Java中创建的对象是放到堆里面的，但Java为了达到更高的性能要求，在高版本(此处指JDK8)中，有时会将对象直接生成在栈里面</description>
    </item>
    
    <item>
      <title>i&#43;&#43;和&#43;&#43;i到底怎样执行的？</title>
      <link>/zh-cn/posts/i&#43;&#43;%E5%92%8C&#43;&#43;i%E5%88%B0%E5%BA%95%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E7%9A%84/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/i&#43;&#43;%E5%92%8C&#43;&#43;i%E5%88%B0%E5%BA%95%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E7%9A%84/</guid>
      <description>前言：i++和++i的区别是什么？大家伙肯定会想到答案： i++先赋值再运算；++i是先运算再赋值；这个问题也算是比较基础的问题了，一般笔试也</description>
    </item>
    
    <item>
      <title>多年后才知道Integer判断相等有这个坑</title>
      <link>/zh-cn/posts/%E5%A4%9A%E5%B9%B4%E5%90%8E%E6%89%8D%E7%9F%A5%E9%81%93integer%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E6%9C%89%E8%BF%99%E4%B8%AA%E5%9D%91/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E5%A4%9A%E5%B9%B4%E5%90%8E%E6%89%8D%E7%9F%A5%E9%81%93integer%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E6%9C%89%E8%BF%99%E4%B8%AA%E5%9D%91/</guid>
      <description>前言：今天在改完代码后进行接口测试时，突然发现自己写的一个接口一直提示错误，检查代码查发现这个坑。 逻辑是这样的，我在controller层方</description>
    </item>
    
    <item>
      <title>干掉你写的 obj != null吧，真心不好看</title>
      <link>/zh-cn/posts/%E5%B9%B2%E6%8E%89%E4%BD%A0%E5%86%99%E7%9A%84-obj-null%E5%90%A7%E7%9C%9F%E5%BF%83%E4%B8%8D%E5%A5%BD%E7%9C%8B/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E5%B9%B2%E6%8E%89%E4%BD%A0%E5%86%99%E7%9A%84-obj-null%E5%90%A7%E7%9C%9F%E5%BF%83%E4%B8%8D%E5%A5%BD%E7%9C%8B/</guid>
      <description>前言：在平时开发过程中，字符串的非空判断时有发生，我们最常用到的a != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(a) 虽然没啥问题，但是真心不好看，这里有一些其他的非空校验方法希望可以</description>
    </item>
    
    <item>
      <title>JVM内存结构详解</title>
      <link>/zh-cn/posts/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</guid>
      <description>前言：JVM就是我们平时开发经常提到的Java虚拟机（Java Virtual Machine），既然是虚拟机，那他肯定具备真实计算机的功能，只不过不是从硬</description>
    </item>
    
    <item>
      <title>假如躺平也开始内卷。。。</title>
      <link>/zh-cn/posts/%E5%81%87%E5%A6%82%E8%BA%BA%E5%B9%B3%E4%B9%9F%E5%BC%80%E5%A7%8B%E5%86%85%E5%8D%B7/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E5%81%87%E5%A6%82%E8%BA%BA%E5%B9%B3%E4%B9%9F%E5%BC%80%E5%A7%8B%E5%86%85%E5%8D%B7/</guid>
      <description>前言：各位码友，今天不说技术，聊聊最近比较火的两个词，内卷和躺平。 内卷和躺平啥意思？ 内卷：本意是指人类社会在一个发展阶段达到某种确定的形式后</description>
    </item>
    
    <item>
      <title>搞了一天的String和internal，终于想通了</title>
      <link>/zh-cn/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84string%E5%92%8Cinternal%E7%BB%88%E4%BA%8E%E6%83%B3%E9%80%9A%E4%BA%86/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84string%E5%92%8Cinternal%E7%BB%88%E4%BA%8E%E6%83%B3%E9%80%9A%E4%BA%86/</guid>
      <description>前言：铁汁们，今天又是代码被虐爆肝的一天，被啥虐了嘞，看标题就知道了，话不多说上代码。 1public class StringInternTest { 2 3 public static void main(String[] args) { 4 5 String s1 = &amp;#34;1&amp;#34;; 6 String s= new String(&amp;#34;1&amp;#34;); 7 s.intern(); 8 System.out.println(s</description>
    </item>
    
    <item>
      <title>5月收官，编程语言排名的后宫大戏</title>
      <link>/zh-cn/posts/5%E6%9C%88%E6%94%B6%E5%AE%98%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E5%90%8D%E7%9A%84%E5%90%8E%E5%AE%AB%E5%A4%A7%E6%88%8F/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/5%E6%9C%88%E6%94%B6%E5%AE%98%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E5%90%8D%E7%9A%84%E5%90%8E%E5%AE%AB%E5%A4%A7%E6%88%8F/</guid>
      <description>前言：看到Java和Python的相爱相杀，我脑补出了一部后宫争斗大戏（无语言歧视，只是娱乐，皮一下各位看官请轻喷~）。 演员表(角色按排名分</description>
    </item>
    
    <item>
      <title>App发送短信验证码实现</title>
      <link>/zh-cn/posts/app%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/app%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>前言： 现如今，电话是接外卖和快递的，短信是用来收验证码的。那么像一般的App里面使用手机号+验证码方式进行注册或登录是怎样实现的呢？这篇文章</description>
    </item>
    
    <item>
      <title>双亲委派机制笔记</title>
      <link>/zh-cn/posts/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 29 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%AC%94%E8%AE%B0/</guid>
      <description>1，什么是双亲委派机制？ 我的理解是，在java中，当类加载器需要对class文件进行加载时，会递归调用父加载器，当父加载器加载失败时，再向下</description>
    </item>
    
    <item>
      <title>springboot &#43; log4j2 演示demo</title>
      <link>/zh-cn/posts/springboot-&#43;-log4j2-%E6%BC%94%E7%A4%BAdemo/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/springboot-&#43;-log4j2-%E6%BC%94%E7%A4%BAdemo/</guid>
      <description>项目中一直有使用日志，以前都是面向CV编程，今天整理了下常用的两种输出方式（ConsoleAppendert和RollingRandomAc</description>
    </item>
    
    <item>
      <title>springboot 使用切面记录请求参数与返回结果</title>
      <link>/zh-cn/posts/springboot-%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2%E8%AE%B0%E5%BD%95%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/springboot-%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2%E8%AE%B0%E5%BD%95%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/</guid>
      <description>使用切面记录请求参数与返回结果 因为在上月底有一次大的版本上线，而因为前期测试不足导致上线后系统不太稳定，所以才打算把这块补上。。。 1@Aspect 2@Component 3@Order(1) //</description>
    </item>
    
    <item>
      <title>docker安装redis使用自定义配置，启动失败</title>
      <link>/zh-cn/posts/docker%E5%AE%89%E8%A3%85redis%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh-cn/posts/docker%E5%AE%89%E8%A3%85redis%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</guid>
      <description>@TOC 代码如下： 1docker run -p 6379:6379 --name redis-test 2-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf 3-v /usr/local/docker/redis/data:/data 4-d redis redis-server /etc/redis/redis.conf 5--appendonly yes 但是始终不行，后来查原因为【redis.conf】文件里面有一个配置设置错误 因为之前是手动安装的</description>
    </item>
    
  </channel>
</rss>
