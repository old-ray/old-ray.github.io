[{"categories":["后端"],"content":"Docker安装jenkins部署springboot项目\n起因：测试服务器要过期了，想着新购一台服务器会便宜百来块钱，出于为公司省钱的心理，就同意了这个方案，但然并卵，将原服务器的镜像制作好放到新服务器后，哦豁，jenkins启动失败，提示一些错误，求助阿里官方给的回复是，阿里不会对服务器做任何限制，建议我重新安装jenkins!!!，天雷滚滚。想着之前安装的时候记录过步骤，应该不会太难搞，结果是安装依然会有这个问题，好嘛，只能硬着头皮曲线救国，干脆用docker安装吧。ps：这里省略了docker本身的安装过程，因为原服务器之前就有，上面还跑了redis，镜像同步过来也没有问题。所以我只需要安装jenkins就行了。\n踩坑：\n1，端口忘记开放，后期改配置文件但不生效，只能重来，但好在jenkins_home目录我是挂载在宿主机上了，所以没有多少损失\n2，虽然在启动容器的时候将localtime与宿主机同步，但启动的springboot项目的日志时间仍然差了8小时\n在项目启动时，设置虚拟机的时区\n​ nohup java -jar -Duser.timezone=GMT+08 ${jar_name} \u0026amp;\n3，jenkins构建项目的时候，将旧的jar包删除时提示没有权限\n在宿主机中将文件删掉，并执行chmod 777 给权限\n4，jenkins是在容器里面创建的，启动的项目也在容器中，但宿主机中也会有对应的java进程，所以需要将宿主机中的进程kill掉\njenkins安装SSH插件，在启动项目前将进程kill掉【Execute shell script on remote host using ssh】\n1# 一，下载 2docker pull jenkins/jenkins 3# 二，在宿主机上创建jenkins_home目录 4mkdir -p /var/jenkins_mount 5chmod 777 /var/jenkins_mount 6# 三，运行，我这里将jdk和maven仓库存放的目录也放进来了 7docker run -d -p 9901:8080 -p 10241:50000 -p 8002:8002 -p 8003:8003 -p 8006:8006 -p 8007:8007 -v /var/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime -v /data/www/xhapi:/data/www/xhapi -v /root/.m2:/root/.m2 -v /server/jdk1_8:/server/jdk1_8 --name myjenkins jenkins/jenkins 8# 四，通过浏览器访问jenkins控制台 9jenkins.test.xinheshu.com 10# 五，安装maven插件，我选的推荐安装里没有安装maven插件，这里安装一下，这样在创建任务的时候可以创建java项目了 11# 六，其他，下面的命令是我在打包xin-admin项目的时候用到的，这样可以单独安装xinhe-admin 12clean install -pl xinhe-admin -am -amd ","date":"2022-11-15","img":"","permalink":"/posts/docker%E5%AE%89%E8%A3%85jenkins%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/","series":["Java"],"tags":["Jenkins"],"title":"Docker安装jenkins部署springboot项目"},{"categories":["静态网站"],"content":" 搭建一个属于自己的个人博客网站，这种想法由来已久。之前也尝试过，但结果不尽如人意。最近无意中知晓Hugo这种框架，无需编写前端代码通过一些参数配置修改就可定制自己想要的博客网站，于是又开始熬夜了。。。\n HUGO 框架（点此传送官网\r） 果然厉害的东西，愿景标语都是如此刚。尝试搭建之后确实比较有意思。他是用go语言编写实现的静态网站生成器。因为阿雷没接触过go语言，所以本文是小白文，只会介绍框架的使用方法。ps：这个框架的中文阿雷一直读作虎狗，查了下中文翻译竟然是雨果。。。 下载（传送门\r） 官方介绍了好几种安装方式，找了一种最简单的方式直接下载启动文件安装。 里面也有windows版本的文件，如果要直接看效果的话用windows,因为linux一般是命令控制台无法查看效果，除非是通过宝搭或者虚拟机中查看。但如果要发布到外网的Linux服务器，还是建议在Linux系统上安装和打包，阿雷就吃过亏。后续会总结遇到的一些坑。\n安装 Linux系统 将安装包移动到/usr/local/bin目录下解压即可，解压命令如下\n1$ tar zxvf hugo_0.88.1_Linux-64bit.tar.gz 解压出来就几个文件，主要就是hugo这个文件，到此就安装完成了，非常简单 Windows系统 同样也是下载windows系统的安装包，解压目录可以解压到C:\\Windows\\System32目录下，或者把解压目录添加到环境变量Path目录里面，保证系统可以找到执行文件都可以，(hugo命令是不能直接双击打开的，必须使用命令)。\n测试下是否安装成功，在控制台输入hugo \u0026ndash;help命令，如果有打印出版本信息表示安装成功 创建站点 非常简单，一行命令即可初始一个站点，如下\n1$ hugo new site quickstart # quickstart为站点名，可以定义自己想好的网站名都可以 进入目录查看生成的文件 下载主题（点此传送门\r） 选择自己中意的主题(以hugo-theme-bootstrap为例，各主题会略有不同)，点击进去，里面会有安装操作，但一般都是通过git方式下载主题的，git安装和使用就不作说明了，没了解的可以去找个教程看下传送门\r把主题下载到thems目录下，这里建议大家直接克隆下来，不要引用成git的子模块 命令如下：\n1# 主题里面介绍的是引用成git子模式的方式，下文有介绍克隆主题的方式。 2$ git submodule add https://github.com/razonyang/hugo-theme-bootstrap themes/hugo-theme-bootstrap 这个主题里面有一个demo配置，可以应复制到站点中来\n1$ cp -a themes/hugo-theme-bootstrap/exampleSite/* . 2# 如果是windows系统，使用如下命令复制 3$ xcopy .\\themes\\hugo-theme-bootstrap\\exampleSite /E 到此站点已搭建结束了，使用下面的命令即可查看效果啦，简单得不敢相信\n1$ hugo server 在浏览器中输入网址即可访问啦（这里显示的是http://localhost:1313） 总结 好了，现在来总结一下所用到的命令：\n1$ hugo new site quickstart # 创建quickstart站点 2$ cd quickstart # 进入目录 3$ git init # 初始git，如果是测试可不用 4 5# 下载主题 6# 二选一 7$ git submodule add https://github.com/razonyang/hugo-theme-bootstrap themes/hugo-theme-bootstrap 8# 或者 9$ cd themes 10$ git clone https://github.com/razonyang/hugo-theme-bootstrap themes/hugo-theme-bootstrap 11# ps: 有时候使用https协议下载会提示无权限的问题，小伙伴们可以换成git协议，或者通过浏览器打开网址直接下载都行，如果打开网址慢的话，阿雷的传到百度网盘，可以下载 12# 链接：https://pan.baidu.com/s/10ISFN6HmdkydLaJAgdwqbg  13# 提取码：6666 14 15# 如果选的直接clone主题的方式，在执行此命令时记得要回到quickstart目录级 16# cd .. 17$ cp -a themes/hugo-theme-bootstrap/exampleSite/* . 18# windows系统使用如下命令复制 19# xcopy .\\themes\\hugo-theme-bootstrap\\exampleSite /E 20 21#启动站点 22$ hugo server 23 24# 大功告成~  本文简单介绍了如何使用hugo在本地跑起来一个主题博客网站，网站是跑起来了，但是里面的内容如何修改呢？如何发布到外网呢？自己没有服务器也可以在外网部署和访问吗？答案是肯定的。留在下期吧。\n ","date":"2021-10-04","img":"","permalink":"/posts/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80hugo-%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA%E7%BD%91%E7%AB%99/","series":["个人博客"],"tags":["HUGO"],"title":"搭建个人博客（一）：Hugo 框架构建网站"},{"categories":null,"content":" 大佬，好：\n​ 怎么说呢，做一个自己的博客空间，这个想法自初入行到现在就没有断过。在18年的时候其实我就已经部署好了一个博客网站，当时是用的jsp直接在tomcat上面跑，非常简单。因为那个时候目的不在于内容的输出，而是想把部署的整个流程过一遍。从域名和服务器购买，再到域名备案和解析，环境搭建和部署上线，真实体验“一条龙”式服务。所以兴趣头过了之后，就荒废了一段时间。其间也考虑过重新改版一个可管理的博客网站，但想到怎样去做文章页面排版问题就头大，即使是文本编辑器也会有样式问题，还要考虑到评论功能，这样就牵扯到用户登录注册功能，实在令人头大。故而就放弃一直没动。\n​ 直到前两天看到一位大神的博客空间，他说自己的博客网站是用HUGO生成的，顿时令我心神一震，厉害了，这不就是我一直想解决的问题吗？于是乎花了几天时间重新搭建了这个网站，到此这个网站也算是真正建成了。不过其间也是会遇到各种问题。但还好都解决了。以后就要开开心心地肝文了~\n​ 技术无止尽，头发有稀疏。若为Java故，头顶皆可秃。\n   写给自己：\n​ 回顾在互联网浪潮中拼搏这几年，总觉得自己很浮躁。看到大佬写的爆文，心生敬佩同时也很羡慕；见到大牛薪资远高于自己，替人高兴之余也会自我惭愧。我想深漂了这么些年，也是时候好好沉淀一下了。\n​ “沉淀”一词，怎么说呢，初中化学就听到过有关于沉淀物一词的解释，但直到近两年我真正有所体会。当我面对一位面试官的技术提问而久久不能回答时，首先想到的就是沉淀这个词。简单来说就是没有技术积累，工作年限与技术水平不匹配，说白了就是多年的CRUD经验，跟刚入行时候的技术水平没什么两样。每当想到这心里就一阵惊慌，要被淘汰掉了吗？我感觉前所未有的压力。所以在后面那段时间里拼命学习，熬夜出内容。最终也拿到了不错的offer，但随之而来的却是，体重飙升，因为熬夜，出现了一些身体状况，使得这一切不得不停止，并开始强迫自己早睡，午睡，少吃，运动。我不知道别人26的身体情况是怎样的，我是觉得比去年差了很多。可能是年纪来了吧。毕竟，再过几年就是30岁，我就要面临转型或转行的选择了。写到这里突然有点佛系了，这么沉淀下去，不会就真沉了吧？\n​ 好啦丧气话说够啦。其实回过头来再看看自己，入行做开发这几年，真的可以说是改变了我现在的人生。从物质上来说起码这个行业的薪资确实高于其他行业，当然也高于我最初想从事的英语这个行业。当年如果没学这个而是去学英语，那又会是怎样的一个故事呢？我不得而知，也永远不会知道答案。但这个行业也是真的卷，技术永远在更新。你学的东西越多，你就不知道的越多。很容易迷失在里面。空杯心态要求人持续学习。而不是与人攀比。框架，中间件再前卫也是要服务于业务需求。但仍需要保有一颗赤子之心，持续在代码江湖里打怪升级，因为哪天公司业务量上来，你学的东西就有用武之地了。\n ","date":"2021-10-03","img":"","permalink":"/about/%E5%85%B3%E4%BA%8E%E6%88%91/","series":null,"tags":null,"title":"关于我"},{"categories":["虚拟机"],"content":" 前言：虚拟机相信各位小伙伴一定不陌生，我们平时在做项目框架搭建和测试时为了模拟多机器环境经常会用到，但对于初学者不太友好的就是，如果虚拟机或自己的电脑重启了后，虚拟机的IP就变了，这样就使得你不得不去修改项目里配置IP地址，就很麻烦。如果有这种问题的同学，可以接着往下看。\n  注意：本文以centos7 64版本系统为例，其他也大同小异，此处以NAT模式进行配置，仅用作参考。  首先我们需要将虚拟机中对应系统的网络适配器改成NAT模式\n然后再点击Vmware“虚拟网络编辑器”，配置NAT模式网卡（一般写的是VMnet8），先点击更改设置按钮，因为需要使用管理员才可以修改配置，在弹出窗口中选是。\n等到重新加载编辑器窗口后，再点选VMnet8切换回来，配置如下几步，勾选上“将主机虚拟适配器连接到此网络”和“使用本地DHCP服务将IP地址分配给虚拟机”（默认也是勾选的，如果没勾选要勾选上），然后配置下子网IP（如果有值可以不改，一般可以设置为192.168.x.0这种格式），子网掩码一般为255.255.255.0\n再点击NAT设置按钮，配置网关IP，如下：\n再点击DNS设置按钮，取消勾选“自动检测可用的DNS服务器”按钮，再配置DNS服务器，保存关闭窗口\n再切回到主机，如果你的win10系统，在桌面右键选择“个性化”，在搜索框检索 “查看网络连接”，这样就来到了网络配置页面，如下图：\n选中VMnet8，右键属性，在打开的页面中选择“Internet协议版本 4”，再点击属性，如下图：\n在打开的页面进行如下配置：\n接下来我们需要进入到系统中进行配置文件的操作，打开Terminal面板，执行如下命令\n1/etc/sysconfig/network-scripts 找到一个以ifcfg-ens开头的文件，并进行编辑\n1vim ifcfg-ens33 2//如果没有安装vim，可以安装一下，很好用。 3 4//添加如下配置 5ONBOOT=\u0026#34;yes\u0026#34; 6BOOTPROTO=\u0026#34;none\u0026#34; 7NM_CONTROLLED=\u0026#34;yes\u0026#34; 8IPADDR=\u0026#34;192.168.73.123\u0026#34; #这里就是你设置的固定IP 9NETMASK=\u0026#34;255.255.255.0\u0026#34; 10GATEWAY=\u0026#34;192.168.73.2\u0026#34; 11DNS1=\u0026#34;114.114.114.119\u0026#34; 12DNS2=\u0026#34;114.114.115.119\u0026#34; 编辑完成后，需要重启一下网卡，如下：\n1service network restart 最后查看下是否配置成功，使用如下命令：\n1ifconfig 这样就大功告成啦\n","date":"2021-06-21","img":"","permalink":"/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip/","series":["vmware"],"tags":[],"title":"Vmware虚拟机如何设置固定IP"},{"categories":["后端"],"content":" 前言：对于java开发人员来说，spring是必会的一门框架了，于初学者而言，能熟练使用spring就已经很ok了，但对于一匹老码来说，就须得知其然也要知其所以然了，所以从今天起就要开始快乐的学习源码了。今天就索性把源码下载编译出来。\n 1，下载源代码   进入spring官网，访问地址如下（可跳过此处直接访问步骤二中的地址）： https://spring.io/projects/spring-framework\r  点击git图标，就来到了spring项目的下载页面，如下： https://github.com/spring-projects/spring-framework\r  最好选择RELEASE版本，你懂的   使用git命令下载，或直接下载压缩包都可以\n  2， 编译  因为spring是使用gradle打包的，我们在编译前先配置下gradle的国内镜像，找到项目里面的build.gradle文件，在repositories中添加两行代码保存，如下图  1maven{ url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public/\u0026#39;} 2maven{ url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39;}  打开cmd界面，进入到当前spring项目的保存目录，执行如下命令进行编译，因为第一次编译要下载挺多的文件，所以需要耐心等待一下，直接界面出现BUILD SUCCESSFUL字样，表示编译成功（异常错误忽略）  1gradlew :spring-oxm:compilesTestJava 三，项目导入开发工具中（idea）  打开idea，点击菜单栏中的File -\u0026gt; open\u0026hellip;，选中编译好的spring项目，按下图进行选择，再等待idea导入完成即可    总结：为什么想到要看spring源码呢？是爱吗？是责任吗？都不是，因为面试要问啊。而且阅读源码也可以多学习一下大神的编程思路，也算是提升一下自已吧。。我是阿雷，一位忙里写文的程序员。\n ","date":"2021-06-20","img":"","permalink":"/posts/%E7%BC%96%E8%AF%91spring%E7%9A%84%E6%BA%90%E7%A0%81/","series":["spring"],"tags":[],"title":"编译spring的源码"},{"categories":["数据库"],"content":" 前言：通过上节我们知道Mysql将事务设置为可重复读隔离级别后可以避免数据脏读和不可重复读问题。那么可重复读具体是怎样实现的呢？MVCC是个啥？可以接着往下看。\n 我们先看一下定义（维基百科）：\n 多版本并发控制(Multiversion concurrency control， MCC 或 MVCC)，是数据库管理系统常用的一种并发控制，也用于程序设计语言实现事务内存。 MVCC意图解决读写锁造成的多个、长时间的读操作饿死写操作问题。每个事务读到的数据项都是一个历史快照（snapshot)并依赖于实现的隔离级别。写操作不覆盖已有数据项，而是创建一个新的版本，直至所在操作提交时才变为可见。快照隔离使得事物看到它启动时的数据状态。  大概意思是，在Mysql中，我们修改数据时并不是直接将旧数据抹除，而是将新数据“盖在”旧数据上面，这样处理对于修改数据前已经查询过数据的用户是没有影响的，还是可以查看到历史版本的数据，从而实现可重复读。\n 阿雷每天上班的路上新开了一块空地准备建写字楼。 第一天经过时才只盖了一层，出于好奇心，阿楼爬上了一楼，打算去看下是个什么情况，谁知道把手机落在了那里（好奇心害猫go die）。 隔一段时间后，突然回忆起有去过这么个地方，手机可能就在那里，于是阿雷就赶紧跑过去查看，不过这个时候房子已经盖到六层了。 可是阿雷知道即使房子已经建到六层，但我还是要去一楼找，并且还顺利找到了手机。  修改数据就好比盖房子，一层一层往上累计。那在Mysql里面是怎样建这层楼的呢？我们先看个图：\n在数据库中有一张language表，里面有两个字段【id】和【name】，其中trx_id和roll_pointer分别表示当前记录操作的事务id和指向旧数据的指针。\n最开始新增了一条【name = java】的数据，后来修改成为【name = c++】。后续修改操作依此类推，这样就楼房就一层层往上盖。而实际这栋楼叫做【undo日志版本链】。\n那如果其他事务对当前记录进行select操作，怎样保证数据的修改不会影响到其他事务呢？就像阿雷知道即使楼层变了，但我也知道去一楼找手机，而不是去其他楼层呢？\nMysql使用一致性视图read view机制去实现这一逻辑。在可重复读隔离机制下，当我们在事务中执行任何查询sql时，就会生成一致性视图（注意不是begin时就生成视图，而是在执行第一条sql语句时生成），直到事务结束。（读已提交隔离机制是每次查询sql，都会重新生成视图，这也是为什么提交修改的数据后，其他事务可以马上读取到的原因）。\nread view保存了执行查询时所有未提交事务id数组（数组里最小的id为min _id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。\n对比规则：\n trx_id \u0026lt; min_id ，表示trx_id事务已提交，数据可见。 trx_id \u0026gt; max_id ，表示trx_id事务未发生，数据不可见面。 min_id \u0026lt;= trx_id \u0026lt;= max_id  trx_id在视图数组里面，则表示trx_id还未提交，数据不可见(如果当前事务就是自已的，则是可见)。 trx_id不在视图数组里，则表示trx_id已提交，数据可见。    当在新增完【name = java】记录，我们查询数据，这时min_id为空，max_id=100，从上往下索引查询，300\u0026gt;100，200\u0026gt;100，则都是不可见，100不在视图数组里面，所以即使我们后续在进行修改操作，在这个事务里面，我们查询的数据依旧是【name = java】\n 总结：通过本节我们可以知道Mysql通过undo日志版本链和一致性视图来实现MVCC机制，从而实现数据可重复读。阿雷最开始觉得一致性视图的实现是比较绕的，但是只要一想到查询数据前后是不会变的，然后再去推导过程就会豁然开朗。我是阿雷，学无尽，无尽学。\n ","date":"2021-06-19","img":"","permalink":"/posts/mvcc%E5%A4%84%E7%90%86%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%90%86%E8%A7%A3/","series":["mysql"],"tags":[],"title":"MVCC处理可重复读理解"},{"categories":["数据库"],"content":" 前言：从最开始的手工写begin,commit语句，到现在的@Transtional注解，事务看似不起眼也很容易使用，只有在真正接触后发现，确实没什么用。转眼已到七月，夏日炎炎正好眠，所以阿雷打算肝完这节就去睡（来自凌晨一点的问候）。\n 一，事务基本操作,ACID\n 原子性(Atomicity)：这点很好理解。在程序运行过程中，同一个事务里的操作要么都成功，要么都失败（经常案例就是银行的转账，一边扣钱，一边加钱，不能只扣不加）。 一致性(Consistent)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。（像转账操作一边减，一边加，实际钱还是那么多） 隔离性(Isolation)：多个操作并发执行时，通过事务隔离保证数据不被其他事务干扰，而导致结果出错。包括读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable） 持久性(Durable)：事务提交后，如果后续不再操作他，则数据会永久不变。（不会因为重启，宕机而导致数据回滚）。  二，事务隔离级别\n  多个事务对同一条数据的操作会因为隔离级别的不同而呈现不同的情况，会出现如下问题。\n  脏读：比如事务A修改了一条记录还未提交，但当事务B去读取这条记录时却可以读取到事务A修改后的结果，如果事务B对记录进行了修改操作，最后事务A进行回滚操作，这时数据就会出现脏读情况。\n  不可重复读：一个事务在执行完查询的sql语句后，再次执行这条查询语句，竟然数据发生了修改或删除\n  幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”\n  1查看当前数据库的事务隔离级别: 2showvariableslike\u0026#39;tx_isolation\u0026#39;; 3设置事务隔离级别： 4settx_isolation=\u0026#39;REPEATABLE-READ\u0026#39;; 5Mysql默认的事务隔离级别是可重复读， 数据脏读演示：\n不可重复读演示：\n幻读情况演示：\n 总结：今天主要了解了事务的几大隔离级别，以及各级别会出现的几种问题。不过阿雷觉得这些知识在平时开发过程中还是难以应用到的。因为我们一般不会用读未提交和读已提交这两种。但也可能在面试过程中会被问到。所以也了解了一下。今天真开心，又学到了一些没什么用的知识。\n ","date":"2021-06-18","img":"","permalink":"/posts/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","series":["mysql"],"tags":[],"title":"Mysql事务隔离级别"},{"categories":["数据库"],"content":" 前言：最近阿雷在学习关于mysql查询优化中到get一个重要的知识点：索引。虽然以前知道索引，但对索引的了解也仅仅是停留在创建索引层面。所以这几天稍微更深层了解了下，以作后记（这里只讨论mysql）。\n 1，什么是索引\n 官方定义： 在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。   上面说了一大堆，据阿雷了解，在mysql中索引是一种有序的（排好序）的数据结构，能够速度查询出来想要的数据（像新华字典的目录按A-Z排序定位）。  2，创建索引\n1ALTER TABLE `table_name` 2ADD INDEX `INDEX_NAME` (`column_name` ASC); 3，索引的数据结构\n  mysql底层对索引一般使用B+tree结构进行实现。但我还是对比较常见的几种做了下总结：\n  二叉树（Binary tree）：二叉树是每个节点最多有两个子树的树结构，左侧子树节点称为“左子树”（left subtree），右侧子树节点称为“右子树”（right subtree）。每个节点最多有2个子节点的树（即每个节点的度小于3）。 但是这种对于自增的索引（如主键索引）不友好。如下图（图中如果查找数据3，则会从1节点开始向下查找，想象下如果是查找数据100，同样也是从1开始，这样可以说没有起到快速查询的效果）：\n  红黑树（自平衡二叉查找树）：在插入或删除时有做旋转处理，提高查询效率（像刚才二叉树的情况，在红黑树中做了优化处理，元素2变成了root结点，而比2小的1放在左叶，比2大的3在右叶）。\n    Hash表：通过计算hashcode方式可以高效快速定位到对应的记录。但是对于存在排序或范围查找几乎就完全无用了（比如查找年龄大于18的，hash的方式无法查找）。\n  B-Tree：B-Tree的节点中可以冗余保存2个以上的节点。这样做的目的是缩短整个树的高度，节点与叶子节点仍然保持左叶小，右叶大的原则，如下图。\n  B+Tree：相较于B树，B+树在此基础上进行了优化，主节点，是从最底层的叶子结点提炼出来的。B-tree中非叶子节点可以存值；但是B+tree非叶子节点不可以存值，只能存key，所以值只存在叶子节点中，而且最底层的叶子节点之间有指针指向关联。   1// 这里给大家分享一个算法执行可视法演示的网址（需梯子）， 2//有兴趣大家可以自己输入一些数字看一下效果（上面的结果也来从这个网站测试得到的）： 3https://www.cs.usfca.edu/~galles/visualization/Algorithms.html  总结：通过本节总算是对索引有了一个新的认识，不会再听到大佬们说B+Tree的时候一脸懵了。我们平时应该在构思表结构的时候就把索引考虑进去，不然等到数据量大的时候建索可能需发生一些奇奇怪怪的问题。。。我是阿雷，一枚最近被ubuntu和deepin折磨得go die的程序员。\n ","date":"2021-06-17","img":"","permalink":"/posts/%E7%94%B1mysql%E7%B4%A2%E5%BC%95%E6%83%B3%E5%88%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A0%91%E6%8D%AE%E7%BB%93%E6%9E%84/","series":["mysql"],"tags":[],"title":"由mysql索引想到的几种“树”据结构"},{"categories":["后端"],"content":" 前言：本节主要复习下之前所讲过的一些知识点，整理出一些面试题，供各位大佬享用。\n   Java类加载过程 类加载器加载class可以大致分为： 加载 \u0026raquo; 验证 \u0026raquo; 准备 \u0026raquo; 解析 \u0026raquo; 初始化 1）加载：从磁盘中读取字节码文件放入运行时数据区。该过程会产生供开发人员使用的Class对象（如获取类的所有属性，所有方法等）。并且只有在程序运行到要使用该类时才会加载(通过new关键字等)。 2）校验：校验字节码文件格式的正确性(魔数：CAFE BABE) 3）准备：给类的静态变量（类变量）分配内存，给赋予默认等值（null 或 0）; 4）解析：将符号引用替换为直接引用（静态链接）。 5）初始化：将类的静态变量初始化为程序给定的值，执行静态代码块。\n  几大类加载器和双亲委派机制 加载器种类： 1）引导类加载器(Bootstrap)：负责加载JRE目录下的核心类库，如rt.jar 2）扩展类加载器(Extention)：负责加载JRE目录下ext目录中的jar包 3）应用程序类加载器(Application)：负责加载ClassPath目录下的类文件（项目中自已写的） 4）自定义类加载器(Custom)：负责加载用户指定目录下的jar包\n双亲委派机制： 在java中，当类加载器需要对class文件进行加载时，会递归调用父加载器，当父加载器加载失败时，再向下递归传递进行加载，最后加载成功或失败。 如当程序中new Computer()时，应用程序类加载器委托给扩展类加载器，扩展类加载器委托给引导类加载器，引导类加载器findClass失败后向下传递给扩展类加载器，同理扩展类加载器findClass向下传递给应用程序类加载器，此时就可以加载到Computer类。\n优点： 安全加载：沙箱操作，保护核心类不被篡改。 避免类重复加载：当父加载器已经加载了某类时，子加载器就没必要再加载一次。\n  JVM内存结构 JVM包含：类加载子系统，运行时数据区，字节码引擎 运行时数据区：栈，堆，方法区，本地方法，程序计数器 栈：程序计数器，栈帧（局部变量，操作数据栈，动态链接，方法出口），本地方法 堆：年轻代（Eden，sTo，SFrom），老年代\n  JVM常见调优参数： 1） ‐Xms：初始堆大小 2）‐Xmx：堆最大内存 3）‐Xmn：年轻代内存大小 4）‐Xss：栈线程大小 5）‐XX:MetaspaceSize：指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M 6) ‐XX:MaxMetaspaceSize：元空间最大值，默认-1\n  Java对象创建过程 步骤：类加载检查 \u0026raquo; 分配内存 \u0026raquo; 初始化 \u0026raquo; 设置对象头 \u0026raquo; 执行init方法 1）类加载检查：会判断类是否已经加载，如果没有加载会执行第一道题步骤。\n2）分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为 对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。\n分配方法：\r1）指针碰撞：如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点 的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。\r2）空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟 机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录\r内存分配并发处理：\r1）CAS（compare and swap）：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。\r2）本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。\r 3）初始化：给对象的实例字段分配初始值（与类加载赋初始值区分）\n4）对象头：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对 象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。\n5）执行init方法 执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋代码中设定的值，和执行构造方法\n  对象内存分配方式 1）栈上分配：逃逸分析与标量替换，保证对象随着出栈而销毁\n2）年轻代Eden区：朝生夕死对象，会有Minor GC比较频繁，回收速度一般也比较快，Minor Gc会将存活对象在sTo和sFrom区移动清理\n3）老年代分配： a）大对象直接进入老年代 b）对象年龄超过阈值进入老年代 c）对象动态年龄判断 d）老年代空间分配担保机制\n  内存回收算法 1）引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0 的对象就是不可能再被使用的。效率高，但是存在对象相互引用的问题，造成内存泄漏\n2）可达性分析算法：将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的 对象都是垃圾对象 GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等\n  垃圾收集算法 1）分代收集算法：根据对象存活周期的不同将内存分为几 块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n2）复制算法：它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的 内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对 内存区间的一半进行回收。\n3）标记-清除算法：算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标 记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。会产生空间碎片\n4）标记-整理算法：根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回 收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n  垃圾收集器种类与常见垃圾收集器回收过程 1）种类：\n2）收集过程： Serial收集器：串行垃圾收集器。当他进行垃圾收集时，会直接暂停所有用户线程，单线程收集直到收集结束。总体来说serial收集器结构比较简单，垃圾回收的速率比较慢，频繁的STW体验也不友好。\nParallel收集器：多线程版本，同样也会STW。\nParNew收集器：多线程版本，会STW，可以结合CMS组合收集。\nCMS垃圾收集器：实现了应用线程与GC线程同时运行（几乎），步骤如下：\n 初始标记：暂停所有的用户线程，并标记GC Root的直接可达对象，速度很快。\r并发标记：从GC Root的直接关联对象向下遍历所有对象，所以过程耗时比较长，但是此处不需要停止用户线程，可以同时与gc线程一同运行。\r重新标记：因为在并发标记过程中，很可能对象的状态已经发生变动（对象在并发过程中是可达的，但是在并发结束后马上变成垃圾对象了），所以此步骤是一个查漏补缺的操作，但是相比较于并发标记STW，此步骤耗时就少多了。\r并发清理：GC开始对垃圾对象进行回收，并且用户线程也可以同时运行。\r并发重置：重置本次GC过程中的标记数据。\r G1垃圾收集器：Garbage-First收集器主要应用在配备大内存，多核处理器的机器上面。他以高概率满足垃圾收集暂停时间目标，同时在几乎不需要配置的情况下实现高吞吐量。G1 旨在使当前应用程序和环境在停顿和吞吐量之间提供最佳平衡。\n  字符串常量池位置变化，底层实现，intern方法赋值逻辑 1）位置变化：\nJdk1.6及之前： 有永久代, 运行时常量池在永久代，运行时常量池包含字符串常量池\rJdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里\rJdk1.8及之后： 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里\r 2）底层实现：字符串常量池底层是hotspot的C++实现的，底层类似一个 HashTable， 保存的本质上是字符串对象的引用\n3）intern方法说明：\n  1String s3 = new String(\u0026#34;a\u0026#34;) + new String(\u0026#34;b\u0026#34;); 2s3.intern(); 3String s4 = \u0026#34;ab\u0026#34;; 4System.out.println(s3 == s4); 5// 在 JDK 1.6 下输出是 false 6// 在 JDK 1.7 及以上的版本输出是 true JDK7之前是这样，直接复制一个字符串放到常量池中，而在JDK7之后，常量池就放进堆里面一起存放了，所以不需要再复制对象而是直接添加对象的引用到常量池就可以了。\n 总结：JVM的面试题都是比较抽象的概念性题目，如果硬记的话估计过会就会忘掉，所以更多要靠自己的理解。阿雷也把这些题目重新再梳理一遍放在这里，不记得了就拿出来看看，算是加深印象。我是阿雷，夜深人静，正是打代码的好时候。\n ","date":"2021-06-16","img":"","permalink":"/posts/jvm%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","series":["Java"],"tags":[],"title":"JVM常见面试题"},{"categories":["后端"],"content":" 前言：之前我们讲过CMS收集器的回收过程，有一步骤是并发标记，他会在不停止应用线程的情况下判断是否为垃圾对象。感觉就像是你在家里打扫卫生时，你儿子又在一旁丢垃圾一样。这些新出现的垃圾如何处理？再有你认为是垃圾的东西，你儿子却又拿过去玩怎么办？相反你认为有用的东西，实际上又变成垃圾了咋整？\n 一，三色标记概念 这里三色可以理解为gc过程中对象的扫描状态。采用可达性分析算法，从Gc Roots逐级往下查找。 黑色：表示当前对象已经被垃圾收集器访问过，并且对象里面的所有引用都扫描过。表示对象是存活的 灰色：表示当前对象已经访问过，但对象里面的引用还没有扫描或只扫描了部份。 白色：表示当前对象暂未被扫描过。默认所有对象为白色的，如果扫描分析结束对象仍然是白色，则证明不可达，从而可能被当成垃圾回收掉。\n二，多标和漏标的问题 1，多标 即你认为有用的东西，实际上变成没用的。想象下在并发标记过程中，gc可能先扫描到了对象并把对象标记为非垃圾对象，但后来应用线程把对象的引用都删除掉了，此时对象应该变成白色成为垃圾对象，但是gc不知道。这种情况就是多标，多标会产生浮动垃圾，而本次gc并不会回收这部份垃圾，而会留到下次gc过来回收。\n2，新增对象 即在标记过程中，又有新对象挪到了老年代中，这种情况下产生的对象都会标记为黑色，本次gc不回收（就算变成了垃圾对象也不会回收）。\n3，漏标 最坑的应该是这种了：你认为是垃圾的东西，你儿子却又拿过去玩怎么办。在标记过程中，出现了已经为黑色的对象引用了一个白色的对象。因为黑色对象gc不会再扫描了，而白色对象gc又扫描不到，但实际白色对象是存在引用的。这种情况下白色对象是不能够被回收的，否则就会出现严重bug。\n 垃圾收集器会有一个类似于“操作日志”的东西，当我们添加引用或者删除引用的时候，会把这添加和删除的引用记录下来。等并发扫描完成后，重新扫描一次（重新标记）。而这种操作日志有个专有名词叫作写屏障（有点类似切面的概念）\n 增量更新：当应用程序执行中添加对象引用后，会记录这个新增的引用（CMS用的这种处理漏标问题）\n原始快照（SATB）：当应用程序删除对象引用前，会记录这个删除的引用（自行脑补）\n 总结：关于垃圾收集器内容到此就告一段落了。我分了四个章节讲，足以看出他的复杂程度。接下来就是要看一些面试题巩固一下啦，期待下期吧。我是阿雷，一名深漂程序员~\n ","date":"2021-06-15","img":"","permalink":"/posts/%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/","series":["Java"],"tags":[],"title":"并发收集，三色标记算法"},{"categories":["后端"],"content":" 前言：Garbage-First收集器主要应用在配备大内存，多核处理器的机器上面。他以高概率满足垃圾收集暂停时间目标，同时在几乎不需要配置的情况下实现高吞吐量。G1 旨在使当前应用程序和环境在停顿和吞吐量之间提供最佳平衡。\n 一，堆组成与布局\n图中：浅灰色代表空白，红色代表Eden区，红色+S代表Survivor区，蓝色代表老年代，蓝色+H代表Humongous（专门存放大对象的区域）。\n由上图我们可以知道G1将我们堆区域或分成许多小格子（Region），Region的大小都相等，最多可以有2048个Region。Regsion的大小可以通过参数指定，默认是2M（必须是2的次幂，有效值为 1 到 32 MB）。\n1-XX:G1HeapRegionSize //指定Region大小 相比较于之前聊过的收集器，G1虽然也保留了年轻代和老年代的概念，但是不再是连续的内存空间了。而且Region的角色是可以变化的，所以他即可以是年轻代，也可以转换成老年代。还有一点不同的是，G1的对于大对象有一块专门的区域保存（Humongous区），当一个对象的大小超过了一个Region的50%，就会被放过Humongous中，而且如果对象特别大时，可以横跨多个Region存放。而且G1可以设置最大暂停时间（最大STW的时间）\n1-XX:MaxGCPauseMillis=200 //此值设置要合理，否则会起到反效果 二，回收过程步骤\n1. 初始标记（Initial Marking）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；\r2. 并发标记（Concurrent Marking）：用户线程不中断，同时进行可达性分析（同CMS垃圾收集器）；\r3. 最终标记（Remark）：标记在上步骤过程中发生变化的对象（同CMS垃圾收集器）；\r4. 筛选回收（Cleanup）：这里就与CMS有区别了，因为G1是可以设置Gc停顿时间的，所以此阶段G1会对各个Region的回收价值和成本进行计算和排序，尽量在设置的停顿的时间内最大化进行垃圾回收。（比如有1000个Region可以进行回收，但是在设置的STW时间内，只能最多回收800个，那么把800个Region回收掉，这样其实就是以空间换时间了）；在CMS垃圾收集器中，回收阶段是可以与用户线程并行的，但是G1目前需要STW。\r 三，G1的收集模式\n Young Gc Young Gc在所有的Eden区都存放满了之后，会对本次回收做一个时间预估，如果时间比设置的最大gc停顿时间小得多，那么不会马上进行Eden区的回收，而是增加Region给到Eden区，直到近似达到gc最大停顿时间或者Eden区大小达到了最大阈值就会触发gc（默认年轻代对堆内存的占比是5%，最多不超过60%）  1-XX:G1NewSizePercent=5 2-XX:G1MaxNewSizePercent=60 Mixed Gc 当老年代的占有率达到设定的值会触发，他会回收所有的Young和部份old，还有大对象区。Mixed Gc主要使用复制算法，把Region中存活的对象复制到别的Region中去，如果复制过程没有足够的Region，则会触发一次full gc。  四，G1常用设置参数\n五，G1适用场景\n 如果堆内存在8G或16的，建议使用G1 想自主确定STW时间可以使用G1（G1的优势） 垃圾回收时间长（注意不是STW），可以使用G1 对象分配率或年轻代升级老年代很频繁 如果JDK9版本建议使用G1，当然默认也是G1。   总结：从G1回收的步骤我们不难看出，G1应该是在CMS的理论基上进一步改造，使其更加亲和于用于的体验。尤其是他可以通过参数控制最大STW的时间，这一点算是区别于之前几节讲到的收集器的最大不同之处。当然他的实现过程肯定也就越复杂。所以本篇也只能算是G1入门级的文章，还有待深入探究。我是阿雷，父亲节快乐。\n ","date":"2021-06-14","img":"","permalink":"/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%89/","series":["Java"],"tags":[],"title":"Java大头：垃圾收集器（三）"},{"categories":["后端"],"content":" 前言：话接上篇讲了垃圾收集器的几大算法，本篇主要讲对应算法的一些实现。话不多说，先看一张图。\n 图中主要介绍了目前主流的几款垃圾收集器（图中连线表示可以组合收集，不过CMS到Serial Old除外，我标为了红色）。其中Serial，ParNew，Parallel主要负责对年轻代的垃圾回收，CMS，Serial Old，Parallel Old，则是主要对老年代的垃圾回收，G1垃圾收集器就比较厉害，年轻代和老年代都由他收集。\n 就目前而言，没有万能的垃圾收集器，我们需要依据自身的业务情况来选择不同的垃圾收集器。因此清楚掌握每一种垃圾收集器的优缺点也是我们Java开发人员需要学习的一项技能。（PS：方便可以吹水）\n 一，Serial收集器 串行垃圾收集器。当他进行垃圾收集时，会直接暂停所有用户线程，直到收集结束，通俗地说就是一刀切。我们看下运行图：\nSerial + Serial Old 收集器他在收集过程中不光Stop The World，而且他本身还是单线程去收集垃圾对象（年轻代采用复制算法，老年代采用标记整理算法），总体来说serial收集器结构比较简单，垃圾回收的速率比较慢，频繁的STW体验也不友好。\n二，Parallel收集器 随着我们服务器配置越来越高级，我们上面说了Serial收集器是单线程收集，那跟现在的配置相比就显示有点能力跟不上了。正因如此，就出现了Parallel收集器（平行垃圾收集器）。他是可以多线程并发进行垃圾收集，就像一把散弹枪一样，我们看下图：\nParallel + Parallel Old收集器同样也会直接暂停用户线程(STW)，默认的收集线程跟cpu核数相同，也可以指定收集线程数（-XX:ParallelGCThreads），但一般默认不改他。\n三，ParNew收集器 ParNew收集器与Parallel很类似，这里就不画图了，他们区别就在于ParNew可以与我们接下来讲的CMS垃圾收集器组合使用\n四，CMS收集器（Concurrent Mark Sweep） 关于CMS收集器在面试中一般就是重灾区了。因为他用起来是真香。像上面三种收集器，他们整个垃圾收集过程几乎都是STW的，虽然专一，吞吐量高，但同时停顿时间长，对于如今的互联网环境，系统卡顿几乎是一件让人无法忍受的事情。而CMS不一样，他非常注意用户的体验，它第一次实现了gc线程与用户线程同时工作（几乎）。\n初始标记：暂停所有的用户线程，并标记GC Root的直接可达对象，速度很快。\n并发标记：从GC Root的直接关联对象向下遍历所有对象，所以过程耗时比较长，但是此处不需要停止用户线程，可以同时与gc线程一同运行。\n重新标记：因为在并发标记过程中，很可能对象的状态已经发生变动（对象在并发过程中是可达的，但是在并发结束后马上变成垃圾对象了），所以此步骤是一个查漏补缺的操作，但是相比较于并发标记STW，此步骤耗时就少多了。\n并发清理：GC开始对垃圾对象进行回收，并且用户线程也可以同时运行。\n并发重置：重置本次GC过程中的标记数据。\n CMS收集器是一种 “标记-清除”算法实现的，它相比较前面几种垃圾收集器来说算法就更加复杂。但他的优点也是显示易见的，他的停顿点就只有一开始的初始标记和后面的重新标记，这两点的处理速度是非常快速的，所以用户就更容易接受，仅管CMS的GC时间可能比上面几种垃圾收集器的时间更长。\n 但CMS收集器也不是毫无毛病的，他的缺点也比较明显：\n1，CMS在并发标记和并发清理过程中会产生的垃圾就没办法在本次gc过程中回收，只能等到下次gc清理，所以会产生浮动垃圾。\n2，因为CMS使用标记清除算法，所以会产生大量的空间碎片，但是他有参数可以设置在gc完成后进行整理（-XX:+UseCMSCompactAtFullCollection）\n3，我们都知道gc是因为内存空间快要消耗完了我们才会进行回收，但由于CMS在gc过程中用户线程还是运行的，如果gc过程中用户线程以产生了一个大对象放到堆里面，堆空间放不下了，这时就会再次触发“concurrent mode failure”，直接导致STW，然后改为serial old收集器进行回收（本节第一个图中用红线连接的情况）\n 总结：尽管垃圾收集器的出现使用我们程序员不用再去做手动释放内存这种劳心劳力的操作，但并不代表我们就可以完全不用了解他，只做一个拿来主义者。相反这是你区别于其他开发人员的一个关键指标（都给我卷起来）。好了今天就到这里啦，下期我们接着讲一下G1收集器，我是阿雷，一个只敢喝无糖可乐的程序员。\n ","date":"2021-06-13","img":"","permalink":"/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BA%8C/","series":["Java"],"tags":[],"title":"Java大头：垃圾收集器（二）"},{"categories":["后端"],"content":" 前言：万事开头难，先从基础概念讲起吧，老规矩，还是以JDK8版本主讲。\n 一，垃圾收集算法\n 复制算法：将内存分为大小相同的两块（运行区域，预留区域 ），每次分配的对象都存放在运行区域，当运行区域内存不够时，会将存活的对象复制到预留区域，然后清理垃圾对象，结束后运行区域就转变为预留区域，而预留区域就变成了运行区域（有点像survivorFrom和SurvivorTo）\n  标记清除算法：先做标记，再去清除。一般是标记存活的对象，然后统一回收未标记的垃圾对象。\n  标记整理算法：标记整理算法的标记阶段与其他算法一样，但是在整理阶段，算法将存活的对象向内存空间的一端移动，然后将存活对象边界以外的空间全部清空\n 二，什么样的对象才是垃圾？ 在茫茫的java堆中，到处都是对象，怎么分辨这些对象是不是垃圾对象呢？因为一旦搞错对象，就会出现很严重的问题。\n一般有两种方法：\n 引用计数法：当对象被引用时计数器加1，失去引用时计数器减1，当为0时就可以认为对象成为了垃圾对象。但是会有对象相互引用的问题，这样会导致对象永远存在被引用，所以一般不会用这种算法。\n 1public class Test { 2 3 Object test; 4 5 public static void main(String[] args) { 6 Test t1 = new Test(); 7 Test t2 = new Test(); 8 t1.test = t2; 9 t2.test = t1; 10 } 11}  可达性分析算法：GCRoot对象为根节点，然后开始向下查找引用的对象，可能找到的对象标识为非垃圾对象，其他的标记为垃圾对象。 GCRoot节点一般为线程栈的本地变量（局部变量，参数等），静态变量等 （图片引自网络，如有侵权请联系删除）\n  总结：Java垃圾回收机制是我一直想写的一个内容。但因为涉及的东西多，而且也比较难理解，所以本节只是粗略抛出了两个问题：垃圾收集算法和垃圾对象判断机制。阿雷其间有拜读和参考《深入理解Java虚拟机》这本书，有志同道合的朋友可以关注下，共勉。\n ","date":"2021-06-12","img":"","permalink":"/posts/java%E5%A4%A7%E5%A4%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%80/","series":["Java"],"tags":[],"title":"Java大头：垃圾收集器（一）"},{"categories":["后端"],"content":" 前言：虽然现在有像arthas这样强大的调优诊断工具，但懂得操作基础命令也是一项永远不会过时的技能。\n 在某一个漆黑的夜晚，我们努力肝了一个新版本发布上去，第二天却收到服务器告警一查是CPU飙高持续不下，那是什么心情？kill一个程序员祭天吧。\n阿雷会先把旧版本启动并将用户请求切到旧版本上，然后再慢慢找原因。。。为了模拟这种情况，我写了串代码这代码：\n1package com.test; 2public class Test { 3 4 public int cal(){ 5 int a = 1; 6 int b = 2; 7 int c = a + b; 8 return c; 9 } 10 11 public static void main(String[] args) { 12 Test test = new Test(); 13 //无限循环调用cal方法 14 while(true){ 15 test.cal(); 16 } 17 } 18 19} 放到服务器里面编译运行：\n1javac com/test/Test.java 2java com.test.Test 好了，现在用top命令查一下，哦豁，nice。\n现在开始找原因： 1，用top -p 命令，限制显示你要查询的进程，像这样（ 这里pid是30641）。\n1top -p 30641 2，按H键（注意是大写的H），进入查看里面每个线程的情况，找到最高的线程（这里是30642）\n3，然后将30642转换成16进制（注意如是转成的16进制有字母，需要将字母转成小写），因为jstack打印出来的堆栈信息的pid是用的十六进制显示的，所以要做转换。\n1echo \u0026#34;obase=进制;值\u0026#34; | bc 4，使用jstack命令，生成当前线程的快照，然后结合grep命令查找77b2所在行的后面10行的堆栈信息（可以根据情况调整）。\n1jstack 30641|grep -A 10 77b2  总结：jstack命令是java自带的一种堆栈跟踪工具。他能够生成指定线程的快照，打印堆栈信息出来。通过此命令可以快速定位CPU占用率过高问题。除了jstack外常用的命令还有像jinfo，jstat等，这里就不一一例举啦。我是阿雷，一个爱划水的程序员。\n ","date":"2021-06-11","img":"","permalink":"/posts/jstack%E5%AD%A6%E4%B9%A0%E6%89%BE%E5%87%BAcpu%E9%A3%99%E5%8D%87%E4%BB%A3%E7%A0%81/","series":["Java"],"tags":[],"title":"Jstack学习：找出cpu飙升代码"},{"categories":["后端"],"content":" 面试官：HashMap多线程安全么？不安全，为啥不安全？\n 上一期我们看了HashMap#put方法的执行过程，通过源码很容易找出个答案回怼面试官，看下图。\n当两个线程A，B同时拿到modCount同时进行逻辑操作时，就会导致结果不正确。这点好理解。比如A，B线程同时拿到modCount=10，++操作结束后modCount=11，实际应该是12。\n还有吗？ 有。\n再看下这两行代码：\n这里会产生数据覆盖的问题。正常情况下，当key的hash值算出来落到同一个i位置时，会产生链表，但在多线程情况下，假定线程A，B的key计算出来的hash值同时落到i=3的位置，而恰好i=3位置没有任何节点元素，那线程A，B将同时在table[3]位置创建Node节点。最终哪个会真正关联上呢？不得而知。\n那如何解决呢？ 首先，阿雷觉得这不是解决不解决的问题，而是不应该发生的问题，既然都知道HashMap在多线程环境下面不安全了，为啥还要用嘞。（也许你会说，我怎么知道，我来之前代码就这么写的了）。\n解决思路： 1，换了吧，ConcurrentHashMap。 2，put操作时加个锁，像\n1Collections.synchronizedMap(map).get(\u0026#34;key\u0026#34;);//实现逻辑如下：  总结：这几天从第一节讲HashMap中主要的一些常量的意义，到put方法的执行逻辑，最后再解释线程不安全原因。算是对HashMap有一些更深刻的认知了吧（通俗地说就是以后可以拿出去吹水）。关于HashMap的内容暂时告一段落吧。学海无涯，唯勤是岸。我是阿雷，一个努力coding的程序员。\n ","date":"2021-06-10","img":"","permalink":"/posts/%E9%87%8D%E8%AF%86hashmap%E4%B8%89/","series":["Java"],"tags":[],"title":"重识HashMap（三）"},{"categories":["后端"],"content":" 前言：没想到短短的一个put方法，竟然有这么多逻辑。。。\n Hello，昨天大概讲了下HashMap中几个重要的默认值以及HashMap的构造函数，今天主要想看一下存储数据的过程，即HashMap中put方法的实现。\n1public V put(K key, V value) { 2\t//1，先将key进行hash扰动 3\t//2，调用putVal方法 4 return putVal(hash(key), key, value, false, true); 5} 6 7//存储所有元素的数组，默认为null 8transient Node\u0026lt;K,V\u0026gt;[] table; 9 10final V putVal(int hash, K key, V value, boolean onlyIfAbsent, 11 boolean evict) { 12 Node\u0026lt;K,V\u0026gt;[] tab; 13 Node\u0026lt;K,V\u0026gt; p; 14 int n, i; 15 16 //判断table如果为空，调用resize方法初始化table 17 if ((tab = table) == null || (n = tab.length) == 0) 18 n = (tab = resize()).length; 19 20 //(n - 1) \u0026amp; hash 计算出来的值是在0-\u0026gt;n之间的数，即不会超过数组的长度 21 //如果当前数组下标的数据为空，则将当前元素直接存放到i下标位置 22 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) 23 tab[i] = newNode(hash, key, value, null); 24 else { 25 Node\u0026lt;K,V\u0026gt; e; K k; 26 //1，如果table[i]位置已经存在元素， 27 //则判断当前传入的key与当前i位置元素的key是否完全一致，如果一致， 28 //则直接运行到后面去覆盖value值 29 //如： map.put(\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;); 后再次：map.put(\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;); 30 if (p.hash == hash \u0026amp;\u0026amp; 31 ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ 32 e = p; 33 } else if (p instanceof TreeNode){ 34 //2，判断当前table[i]位置的元素如果它已经是树结构，则当前key，value就需要存入到TreeNode中 35 e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); 36 }else { 37 //3，最后就只有链表这种情况了，那就循环遍历链表吧 38 for (int binCount = 0; ; ++binCount) { 39 //如果找到链表的最后一个元素，即p.next == null 40 //那就在链表最后追加一个新节点 41 if ((e = p.next) == null) { 42 p.next = newNode(hash, key, value, null); 43 //判断链表长度是否大于等于8，如果是就要进行树化 44 if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1){ 45 treeifyBin(tab, hash); 46 } 47 break; 48 } 49 //在遍历过程中，判断链表中元素的key， 50 //如果与当前传入的key相同，则会跳出循环 51 //注意循环中的e = p.next，此处跳出循环后e仍旧是有值的 52 if (e.hash == hash \u0026amp;\u0026amp; 53 ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ 54 break; 55 } 56 //继续下一个链表元素进行判断 57 p = e; 58 } 59 } 60 //这里就是value值覆盖操作啦 61 //如果有在数组中找到元素，则需要将当前传入的value覆盖旧的oldValue 62 if (e != null) { 63 V oldValue = e.value; 64 if (!onlyIfAbsent || oldValue == null) 65 e.value = value; 66 afterNodeAccess(e); 67 return oldValue; 68 } 69 } 70 ++modCount; 71 //如果table的长度超过了容器设置的扩展阈值，就会进行扩容 72 if (++size \u0026gt; threshold){ 73 resize(); 74 } 75 afterNodeInsertion(evict); 76 return null; 77 } 代码可能看得有点晕，画一个顺序图吧：\n 总结：今天大致梳理了一下put方法的执行过程。但依旧只是皮毛，没有深究到树化方法的逻辑（treeifyBin），以及树结构put方法存储value的逻辑（putTreeVal），今天就到这吧。我是阿雷，一个逐渐熬夜的程序员。\n ","date":"2021-06-09","img":"","permalink":"/posts/%E9%87%8D%E8%AF%86hashmap%E4%BA%8C/","series":["Java"],"tags":[],"title":"重识HashMap（二）"},{"categories":["后端"],"content":" 前言：当我意识到我对HashMap的了解还停留在键值对，线程不安全的时，我心里咯噔了一下，我想是时候重新认识一下他，希望这种觉悟还不太晚。\n 不同JDK版本中的HashMap实现是有区别的。就国内而言，JDK7和8版本的实现方式到现在都还为大伙所津津乐道，而本节主要是围绕8版本的实现来展开。\n一，静态常量解释\n1\t2\t//默认初始容量16，即数组的初始长度 3 static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 4 5\t//最大的容量，即数组的最大长度 6 static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; 7 8\t//默认的加载因子，当数组里面的元素达到这个比例就会resize() 9 static final float DEFAULT_LOAD_FACTOR = 0.75f; 10 11 //树化阈值，当同一个桶(bin)位置的元素超过此值时会变形成树结构 12 //判断是否可以树化要结合MIN_TREEIFY_CAPACITY（即64）判断， 13 //如果数组的长度小于64 14 //尽管你的树化阈值超过了8，也不会树化，而是会resize() 15 static final int TREEIFY_THRESHOLD = 8; 16 17\t//由树结构转换成链表的阈值，当桶上面的元素数量小于此值会重新变形成链表结构 18 static final int UNTREEIFY_THRESHOLD = 6; 19\t20\t//上面讲过了，树化的前提是数组长度要大于此值 21 static final int MIN_TREEIFY_CAPACITY = 64; 我们大概都听说过JDK8版本的HashMap是由【数组+链表+红黑树】这几种数据结构来实现快速查找和插入的，画一个草图直观感受下：\n二，代码解释\n1Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 这里有一个坑，就是上面这一句代码，虽然是有创建HashMap对象，但是并没真正创建上图所画的数组结构，可以看下源码：\n1 public HashMap() { 2 //此处只加了这么一句代码，设置加载因子为默认值 3 //所以此时table数组实际上仍旧未初始化 4 this.loadFactor = DEFAULT_LOAD_FACTOR; 5 } table的创建实际是在第一次执行put动作时处理的。那怎样执行的呢？明天我们再一起看一下put的执行流程。\n","date":"2021-06-08","img":"","permalink":"/posts/%E9%87%8D%E8%AF%86hashmap%E4%B8%80/","series":["Java"],"tags":[],"title":"重识HashMap（一）"},{"categories":["后端"],"content":" 我们一般认为Java中创建的对象是放到堆里面的，但Java为了达到更高的性能要求，在高版本(此处指JDK8)中，有时会将对象直接生成在栈里面，比如我们常说的栈上分配。\n 我们都知道堆里面的对象回收，是需要等垃圾收集器处理的，但栈中的对象是随着方法调用结束而自行销毁，这样能达到更快释放的效果。那么栈上分配是怎样实现的呢？这里要说到两种机制：\n一，逃逸分析 既然是逃逸，首先得有个“牢房”，在这里可以把每个方法当成一个“牢房”，每一个方法里的对象就是“囚犯”，那怎样逃呢？\n 当我们return 对象返回上级方法，或者是一个静态变量或常量，这样的对象在方法中就困不住，就会逃出去。那这种对象无法控制在方法内进行销毁，我们就称他们可以逃逸，反之则逃逸失败。\n 在JDK中逃逸分析默认是开启的，也可以使用JV参数关闭：\n1-XX:+DoEscapeAnalysis //开启 2-XX:-DoEscapeAnalysis //关闭 我们可以思考下，无法逃逸的对象是不是就可以分配到栈上面随着栈的销毁而直接释放掉呢？\n二，标量替换 标量是指无法再分解成更小粒度的数据，像数值类型。在 JIT 编译过程中，经过逃逸分析确定一个对象不会被其他线程或者方法访问，那么会将对象的创建替换成为多个成员变量的创建，称之为「标量替换」。 比如我们定义一个User类：\n1 class User{ 2 private String name; 3 private Integer age; 4 //省略getter和setter方法 5 public User(String name, Integer age) { 6 this.name = name; 7 this.age = age; 8 } 9 } 当进行栈上分配时，不是将User对象存到栈中，而是将name和age分配进栈。 同样标量替换在JDK8中是默认开启的，也可以关闭：\n1-XX:+EliminateAllocations //开启 2-XX:－EliminateAllocations //关闭 三，测试一下\n1 void test(){ 2 for(int i = 1;i\u0026lt;10000000;i++){ 3 new User(\u0026#34;先生\u0026#34;+1,i); 4 } 5 } 6 7 public static void main(String[] args) { 8 new Test().test(); 9 } 1//关闭逃逸分析和标题替换，将堆内存设为15M，因为创建的对象会直接放进堆中，所以会发生大量Full GC 2-server -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations  总结：栈上分配机制虽然能提升性能，但不是所有的对象都可以这样进行分配，它受制于我们栈内存的大小和我们创建的对象的大小，如果栈内存不足或对象过大，那还是老实老实存入堆里面吧。我是阿雷，一个划水多年的程序员。\n ","date":"2021-06-07","img":"","permalink":"/posts/%E7%90%86%E8%A7%A3%E4%B8%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/","series":["Java"],"tags":[],"title":"理解下栈上分配机制"},{"categories":["后端"],"content":" 前言：i++和++i的区别是什么？大家伙肯定会想到答案： i++先赋值再运算；++i是先运算再赋值；这个问题也算是比较基础的问题了，一般笔试也比较喜欢问。那到底是怎样执行的呢？\n 先看下代码：\n1int i = 0; 2System.out.println(i++); 3int k = 0; 4System.out.println(++k); 输出结果分别是0和1。得出结论是：\n i++先赋值再运算；++i是先运算再赋值\n 结果大伙都知道，那怎样去理解呢？ 我们先看下i++反编译下的代码逻辑：\n1 public static void main(java.lang.String[]); 2 Code: 3 0: iconst_0 //将int类型常量0压入栈 4 1: istore_1\t//将int类型值存入局部变量1 5 2: getstatic #16 // Field java/lang/System.out:Ljava/io/PrintStream; 6 5: iload_1\t//从局部变量1中装载int类型值 7 6: iinc 1, 1 //**这里是直接在局部变量表中进行相加操作** 8 9: invokevirtual #22 // Method java/io/PrintStream.println:(I)V 9 12: return 这里要引入之前讲内存结构是栈桢里的局部变量表和操作数栈，如下图：\n接下来我们看下++i的逻辑代码：\n1 public static void main(java.lang.String[]); 2 Code: 3 0: iconst_0 4 1: istore_1 5 2: getstatic #16 // Field java/lang/System.out:Ljava/io/PrintStream; 6 5: iinc 1, 1 7 8: iload_1 8 9: invokevirtual #22 // Method java/io/PrintStream.println:(I)V 9 12: return 流程图大概是这样：\n 总结：阿雷觉得最坑的就是iinc这一指令操作码，我理解的是iinc是直接对局部变量值进行操作的，所以他跟iload的执行顺序就直接影响到了结果的输出。nice。\n ","date":"2021-06-06","img":"","permalink":"/posts/i++%E5%92%8C++i%E5%88%B0%E5%BA%95%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E7%9A%84/","series":["Java"],"tags":[],"title":"I++和++i到底怎样执行的？"},{"categories":["后端"],"content":" 前言：今天在改完代码后进行接口测试时，突然发现自己写的一个接口一直提示错误，检查代码查发现这个坑。\n 逻辑是这样的，我在controller层方法里面判断service方法返回的结果code如果是1000，则表示逻辑处理成功，否则处理失败。处理逻辑大概如下所示\n1public class Test { 2 3 //定义表示成功的代码 4 public static final Integer SUCCESS_CODE = 1000; 5 6 //定义了响应结果 7 class Response{ 8 private Integer code; 9 public Integer getCode() { 10 return code; 11 } 12 public void setCode(Integer code) { 13 this.code = code; 14 } 15 public Response(Integer code){ 16 this.code = code; 17 } 18 } 19 20 //业务逻辑处理返回成功 21 public Response bizHandler(){ 22 return new Response(1000); //问题代码处一 23 } 24 25 public static void main(String[] args) { 26 Response response = new Test().bizHandler(); 27 if(SUCCESS_CODE == response.getCode()){ 28 System.out.println(\u0026#34;处理成功了\u0026#34;); 29 }else{ 30 System.out.println(\u0026#34;处理失败了\u0026#34;); 31 } 32 } 33 34} 竟然提示我处理失败了？？？\n1000 != 1000吗？ 我突然想到可能是 == 符号的比较在对象之间是判断引用地址是否一致的，很明显，这里一个地址指向在方法区，一个指向在堆中，两者地址并不一样所以结果是false。所以我只需要把问题代码处一的1000改为静态常量SUCCESS_CODE一致即可，如下：\n1 public Response bizHandler(){ 2 //return new Response(1000); 3 return new Response(SUCCESS_CODE); 4} 好了问题暂时解决。 但是我以前代码这样写是没有问题的，于是我就查看以前的代码，发现逻辑大概一致，只不过返回的code是100。换了个值就可以了吗？我于是尝试了下改动：\n1public class Test { 2 3 //定义表示成功的代码 4 public static final Integer SUCCESS_CODE = 100;//这里原来是1000，现在换成100 5 6 //业务逻辑处理返回成功 7 public Response bizHandler(){ 8 return new Response(100);//这里原来是1000，现在换成100 9 } 10} 结果是这样：\n竟然成功了？？？\n说实在的，我是知道有装箱，拆箱这么一说的，装箱调用valueOf方法，拆装调用intValue方法，但是换了个数你就不一样我就很奇怪了，没办法，看下源码吧。\n发现有个IntegerCache这么个东西，cache是缓存的意思吧。原因竟然在这。 原来Java为了提升性能，搞了个常量池，如果你的数值是在常量池里面的，他就直接返回了，这个常量池的范围在-128和127（默认）之间\n所以刚才的code=100结果是true这也就解释得通了。\n 总结：我们一般判断两个Integer类型的数值是否相等会显示的调用intValue进行判断，这样就可以避免出现这种神坑的问题啦。我是阿雷，一个求赞的程序员。\n ","date":"2021-06-05","img":"","permalink":"/posts/%E5%A4%9A%E5%B9%B4%E5%90%8E%E6%89%8D%E7%9F%A5%E9%81%93integer%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E6%9C%89%E8%BF%99%E4%B8%AA%E5%9D%91/","series":["Java"],"tags":[],"title":"多年后才知道Integer判断相等有这个坑"},{"categories":["后端"],"content":" 前言：在平时开发过程中，字符串的非空判断时有发生，我们最常用到的a != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(a) 虽然没啥问题，但是真心不好看，这里有一些其他的非空校验方法希望可以帮到你。\n 一，StringUtils类\n1//该类提供了一系列关于字符串类型的操作方法，如非空校验，包含判断等 2//引入依赖使用： 3\u0026lt;dependency\u0026gt; 4 \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt; 5 \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt; 6 \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; 7\u0026lt;/dependency\u0026gt; 8 9//原来的写法： 10if(a == null || \u0026#34;\u0026#34;.equals(a)){ 11\tSystem.out.println(\u0026#34;a为空的操作\u0026#34;); 12} 13//可以改写成： 14if(StringUtils.isBlank(a)){ 15\tSystem.out.println(\u0026#34;a为空的操作\u0026#34;); 16} 17 18//常用的方法： 19StringUtils.isNotBlank：非空校验，就算全部是空格也会返回false,即也是空 20StringUtils.isNotEmpty：非空校验，如果全部是空格会返回true,即认为有值 21 22StringUtils.isNotBlank(null) = false 23StringUtils.isNotBlank(\u0026#34;\u0026#34;) = false 24StringUtils.isNotBlank(\u0026#34; \u0026#34;) = false //纯空格仍旧认为是空数据 25StringUtils.isNotBlank(\u0026#34;bob\u0026#34;) = true 26StringUtils.isNotBlank(\u0026#34; bob \u0026#34;) = true 27 28StringUtils.isNotEmpty(null) = false 29StringUtils.isNotEmpty(\u0026#34;\u0026#34;) = false 30StringUtils.isNotEmpty(\u0026#34; \u0026#34;) = true //纯空格会认为是非空 31StringUtils.isNotEmpty(\u0026#34;bob\u0026#34;) = true 32StringUtils.isNotEmpty(\u0026#34; bob \u0026#34;) = true 33 34//当然还有取反的方法 35StringUtils.isBlank 36StringUtils.isEmpty 37 38//这个类里面还有很多其他的方法，有兴趣可以看下。 二，MapUtils类\n1//该类可以对Map的value直接指定数据类型返回，也可以同时设置默认值，非常好用。 2//引入依赖使用： 3\u0026lt;dependency\u0026gt; 4 \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; 5 \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; 6 \u0026lt;version\u0026gt;4.1\u0026lt;/version\u0026gt; 7\u0026lt;/dependency\u0026gt; 8 9Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 10map.put(\u0026#34;name\u0026#34;,\u0026#34;张三\u0026#34;); 11map.put(\u0026#34;age\u0026#34;,18); 12map.put(\u0026#34;amount\u0026#34;,0.01); 13 14//原有的写法太过于复杂很容易看错写错： 15String name = (map.get(\u0026#34;name\u0026#34;)==null)?\u0026#34;\u0026#34;:(String)map.get(\u0026#34;name\u0026#34;); 16Integer age = (map.get(\u0026#34;age\u0026#34;)==null)?0:(Integer) map.get(\u0026#34;name\u0026#34;); 17Double amount = (map.get(\u0026#34;amount\u0026#34;)==null)?0d:(Double) map.get(\u0026#34;amount\u0026#34;); 18 19//使用工具类： 20//获取key=name字符串类型数据，为空返回名字。 21MapUtils.getString(map,\u0026#34;name\u0026#34;,\u0026#34;名字\u0026#34;); 22 23//获取key=age整形数值，为空返回0 24MapUtils.getInteger(map,\u0026#34;age\u0026#34;,0); 25 26//获取k=amount双精度数值，为空返回0d 27MapUtils.getDouble(map,\u0026#34;amount\u0026#34;,0d); 28  总结，上面这两个工具类真心好用，虽然有损耗性能的嫌疑，但我想说性能固然重要，但能优雅地写代码取乐自己不也很重要嘛。我是阿雷，一个越来越胖的程序员。\n ","date":"2021-06-04","img":"","permalink":"/posts/%E5%B9%B2%E6%8E%89%E4%BD%A0%E5%86%99%E7%9A%84-obj-null%E5%90%A7%E7%9C%9F%E5%BF%83%E4%B8%8D%E5%A5%BD%E7%9C%8B/","series":["Java"],"tags":[],"title":"干掉你写的 Obj != Null吧，真心不好看"},{"categories":["后端"],"content":" 前言：JVM就是我们平时开发经常提到的Java虚拟机（Java Virtual Machine），既然是虚拟机，那他肯定具备真实计算机的功能，只不过不是从硬件层面真实体现。那么JVM具体包含些什么？本文通过一个示例作出解析。\n 一，结构图我先标在这里，方便有个整体的记忆。 二，写一个简单的例子\n1public class Test { 2 //计算 3 public int calc(){ 4 int a = 1; //第三处代码 5 int b = 2;\t//第四处代码 6 int c = a + b;\t//第五处代码 7 return c;\t//第六处代码 8 } 9\t//主程序 10 public static void main(String[] args) { 11 Test test = new Test(); //第一处代码 12 test.calc(); //第二处代码 13 } 14} 三，我们开始运行程序\n当我们运行main方法时，就生成了一个main主线程，线程实际就会存入到栈里面，那栈里面有什么呢？现在我们放大Thread main线程看看 这里有点套娃，线程里面包含有三块：程序计数器，线程栈，本地方法栈。\n程序计数器：主要是用来记录当前线程代码的执行位置，用于CPU切换线程再回来时能够继续执行。所以计数据器是每个线程所独有的，假定当前已执行到第一处代码，计数器标记为1。\n本地方栈：这个好理解主要是替我们执行Native方法。\n线程栈：采用先进后出（FILO）的方式存储栈帧。那什么是栈帧呢？我们可以把类里面的每个方法就理解成栈帧。上图我只画了main方法的栈帧，接下来我们执行第二处代码，把cal()方法也压入栈。 可以看到cal栈帧里面包含四个部份： 局部变量：如cal里面定义的变量a，b，c，他们是相对于栈帧进行隔离的，存放在这个区域。 操作数栈：随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。当我们运行第三，四，五行代码的时候，这里实际就是将1，2两个数压入操作数栈中，当cpu进行相加操作完成后再将数3出栈返回给c。 我们可以在Test.class目录用javap命令查看指令逻辑\n javap -c Test.class\n 1 public int calc(); 2 Code: 3 0: iconst_1 //将int类型常量1压入操作数栈 4 1: istore_1\t// 将int类型值存入局部变量1 5 2: iconst_2 6 3: istore_2 7 4: iload_1\t//从局部变量1中装载int类型值 8 5: iload_2 9 6: iadd\t//执行int类型的加法 10 7: istore_3 11 8: iload_3 12 9: ireturn\t//从方法中返回int类型的数据 动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接 方法出口：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。\n好了说完栈，我们聊下堆，我们都知道，像我们第一行代码new Test();，实际这个对象就存储在堆中，要知道java作为高级语言，我们是有垃圾回收机制自动帮我们回收无用的对象的，也就是我们平时说的GC。这期我们不展开讲GC，只讲下堆里面的各个区间，如下图： 堆可以分为两代：年轻代和老年代 年轻代可以分为：Eden区，Survivor To，Survivor From 我们生成的对象大部份都是朝生夕死的，所以一般会存放到年轻代的Eden区，当成为垃圾对象后，gc会对其进行回收，并将余下未回收的对象，存入Survivor From区，并将对象的年龄加一，等到下次gc，会连同Eden区和Survivor From区里面的对象一起回收，并将未回收成功的对象放入Survivor To区，并继续将年龄加一，依次往复，当对象年龄超过15次（默认），会将对象移到老年代，老年代了咋整？放心老年代也会gc的，只不过方式不太一样。\n最后还剩下方法区：方法区主要存放我们的类信息，常量和静态变量，所以这块区域是公有的。  总结：今天算是对JVM总体结构有一个比较深刻的认识。学习还是要知其然知其所以然，我是阿雷，一个没秃顶的程序员。\n ","date":"2021-06-03","img":"","permalink":"/posts/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/","series":["Java"],"tags":["jvm"],"title":"JVM内存结构详解"},{"categories":["后端"],"content":" 前言：各位码友，今天不说技术，聊聊最近比较火的两个词，内卷和躺平。\n 内卷和躺平啥意思？\n 内卷：本意是指人类社会在一个发展阶段达到某种确定的形式后，停滞不前或无法转化为另一种高级模式的现象。 当社会资源无法满足所有人的需求时，人们通过竞争来获取更多资源。 经网络流传，很多高等学校学生用其来指代非理性的内部竞争或“被自愿”竞争。（源自百度百科）\n  躺平：指无论对方做出什么反应，你内心都毫无波澜，对此不会有任何反应或者反抗，表示顺从心理。另外在部分语境总表示为：瘫倒在地，不再鸡血沸腾、渴求成功了。（源自百度百科）\n 噢，到底啥意思？\n一天，阿雷隔壁同事小明中午吃了桶泡面，吃得那叫一个香，惹得阿雷非常羡慕，馋得不行。于是第二天，我也吃了一桶泡面，小明见到了我在吃，心想：\n“哟呵，你也吃泡面？还跟我吃一样的，不行，我得吃得比你好”。于是小明就吃了一桶老坛酸菜面。\n我一见还得了：“你吃酸菜的了不起啊，我得搞桶麻辣牛肉的”。\n小明：“那我吃豪华卤香牛肉的”。\n我：“那我吃两桶”。\n小明：“我吃三桶，比你多”。\n于是就这样不停加码，反复地你大我，我压你。（有卷那味了~） 。。。\n终于有一天，小明累了，要 quit，要躺平。\ntoo young ,too simple 你以为躺平就完事啦？躺平也能卷。\n阿雷一瞧，你躺？我也躺。\n你晚上十一点躺，我就晚上十点躺；\n你躺地上，我躺床上；\n你躺着开风扇，我就躺着开空调；\n你躺在小区里，我就躺在别野里；\n你躺着坐公交，我就躺着坐小车。\n那我躺着不动总行吧？\n那不行，我也躺着不动，眼睛都不带眨的，你要是连心跳都没有我就算你赢。\n当然这是玩笑话。 不过这俗话说得好，有人的地方就有江湖。卷这个问题我想大概率是杜绝不了的，但如果能把它好好运作，形成良性竞争的话，这样也许就成就你好，我好，大家好的局面。况且，资本那灵敏的鼻子总是不停地在嗅探着市场，人人都躺平了，我估计什么“躺平经济”也要应运而生了。\n最后作为一个95后，我觉得大伙嚷嚷着说要躺平，只不过是平时面对压力的一种宣泄，说完了，还是得照常上班，努力搬砖，顺便有时还会点个赞，您说是吧？\n我是阿雷，一个恍恍惚惚的程序员。\n","date":"2021-06-02","img":"","permalink":"/posts/%E5%81%87%E5%A6%82%E8%BA%BA%E5%B9%B3%E4%B9%9F%E5%BC%80%E5%A7%8B%E5%86%85%E5%8D%B7/","series":["开心一下"],"tags":["躺平"],"title":"假如躺平也开始内卷。。。"},{"categories":["后端"],"content":" 前言：铁汁们，今天又是代码被虐爆肝的一天，被啥虐了嘞，看标题就知道了，话不多说上代码。\n 1public class StringInternTest { 2 3 public static void main(String[] args) { 4 5 String s1 = \u0026#34;1\u0026#34;; 6 String s= new String(\u0026#34;1\u0026#34;); 7 s.intern(); 8 System.out.println(s == s1); 9 10 String s3 = new String(\u0026#34;a\u0026#34;) + new String(\u0026#34;b\u0026#34;); 11 s3.intern(); 12 String s4 = \u0026#34;ab\u0026#34;; 13 System.out.println(s3 == s4); 14 15 } 16} 运行结果是这样： 起初我觉得不可思议，两串差不多的代码，运行结果却是截然相反，而且 在我的印象里，String类型的数据判断是否相等要用equals方法，定义两个String类型的变量用==号判断结果为true我还是头一次见到，真是越学越放弃。所以不懂就要问度娘：\n Java为了提高性能，对基本数据类型和String类型提供了常量池的概念，相当于就是做了缓存处理了。 对于String类型数据：\n 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的对象，可用使用String的intern方法。intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。   啥意思？ 先看下s和s1 结果同我预想的一样，s1指向的是常量的地址，s是指向堆中的地址，二都不相等，结果为false。 再来看下s3和s4： 但是不对啊，我s3还是指向的堆里面的地址，s4是指向的常量池里面的地址，这不还是一样不相等吗？ 纠结了很久才找到答案：\n JDK7之前确实是这样，直接复制一个字符串放到常量池中，而在JDK7之后，常量池就放进堆里面一起存放了，所以不需要再复制对象而是直接添加对象的引用到常量池就可以了。\n 所以最终图可以这么画： 我是阿雷，我在秃头的路上等着你。\n","date":"2021-06-01","img":"","permalink":"/posts/%E6%90%9E%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84string%E5%92%8Cinternal%E7%BB%88%E4%BA%8E%E6%83%B3%E9%80%9A%E4%BA%86/","series":["Java"],"tags":["String"],"title":"搞了一天的String和internal，终于想通了"},{"categories":["后端"],"content":" 前言：看到Java和Python的相爱相杀，我脑补出了一部后宫争斗大戏（无语言歧视，只是娱乐，皮一下各位看官请轻喷~）。\n 演员表(角色按排名分配)    语言 角色     C 皇后   Python 贵妃   Java 贵妃   C++ 贵妃   C# 妃   PHP 嫔   其他 群演    后宫月度总结大会进行中\u0026hellip; C皇后：  各位妹妹，这月末总结又到了，各位的KPI也都出来了，表现得怎么样，大伙都说说吧。（凭老娘的位份，都懒得瞅你们）。\n Python贵妃：  （抢着开口）C姐姐，都是妹妹的错，本月竟然超过Java姐姐得了第二，内心惶恐不安，怕惹怒了Java姐姐，扰得后宫不宁，Java姐姐，妹妹只是无心之失，姐姐不会怪妹妹吧。（非常茶的口吻）\n Java贵妃：  （哼，兼任就是矫情，看老娘怎么怼你）妹妹说的哪里话，都是自家姐妹，说什么怪不怪的。况且妹妹正得盛宠，业绩高些也是应该得。（小样，得宠又怎么样，还不是只比老娘高那么一点点，老娘家大业大，怕你这点业绩？）\n C++贵妃：  回C姐姐的话，妹妹能有今日地位，多亏C姐姐平日的照拂，在宫里有自家的姐妹真好，妹妹但愿与世无争，与众位姐妹和平共处。（脸上笑嘻嘻，心里MMP）。\n C#妃：  （呵呵。老娘不出声，看着你们斗。同样都姓C，一个当皇后，一个是贵妃，老娘混了这么久却还只是个妃位，我好恨。想当年我也荣耀过，当年跟Java这个兼任平起平坐的时候，你Python连个P都还没有，要不是母家不给力，现在还有你们说话的份？）\n PHP嫔：  （岔开话题）各位姐姐，容妹妹说一句，这KPI固然重要，但也要注意保养，尤其是我们女人，到时千万别因为芝麻，丢了西瓜。你们说是不是啊姐姐们。（呵呵，老娘是世界上最好的，皇上不来看我，定是被你们这起子狐媚子迷了眼，只要皇上看到我，就肯定不会再忘记我。）\n C皇后：  P嫔的话倒是有几分道理，大伙都要跟P嫔好好学学，免得到时候在皇上面前错了主意，惹得皇上不高兴批评了你们，再让本宫知道了那可就不是批评这么简单了,你说是吧，P嫔。好了，本宫也累了，今天就先到这吧，大伙都散了吧。(竟然说要老娘注意保养，我呵呵哒。)\n 阿雷想请问下各位目前用了哪些语言呢？如果真有这后宫情景，他们又会说些啥想些啥呢？图个乐~\n","date":"2021-05-31","img":"","permalink":"/posts/5%E6%9C%88%E6%94%B6%E5%AE%98%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E5%90%8D%E7%9A%84%E5%90%8E%E5%AE%AB%E5%A4%A7%E6%88%8F/","series":["语言"],"tags":[],"title":"5月收官，编程语言排名的后宫大戏"},{"categories":["后端"],"content":" 前言： 现如今，电话是接外卖和快递的，短信是用来收验证码的。那么像一般的App里面使用手机号+验证码方式进行注册或登录是怎样实现的呢？这篇文章可能帮到你。\n 1.寻找合适的短信平台 因为三大运营商的限制摆在那里，凭个人力量当然是不太可能直接发送短信给到用户。所以我们只好依托强大的平台来做后盾。像阿里云，腾讯云等都有提供短信通知服务，虽然平台众多，但实现方式大体相同。此处以阿里云短信为例。\n2.注册阿里云账号（已有账号可跳过） 使用钉钉，淘宝或支付宝扫码注册均可，链接如下，进入后点击右上角注册按钮跳转注册页面：\n https://cn.aliyun.com/\r 3.开通短信服务，购买短信套餐包 购买地址: 点击跳转\r如果链接失效，可以在阿里云首页搜索短信服务，点击后再点立即购买即可跳转，截图如下（如果提示未开通短信服务，只需要确定开通即可）： 4.短信签名和短信模板申请 购买成功后，点击首页的控制台进入，如果找不到短信入口，可以在产品服务里面搜索到，截图如下，这样就进入控制台啦： 5.添加短信签名与模板（国内消息）  签名（点击添加按钮，填写相应资料，保存等待审核即可） 签名指的是短信内容里面中括号【】包含的文本，用作发送方身份标识。  模板 模板即为短信的正文内容，点击添加模板按钮，填写相关资料提交审核。 模板里面的变量使用${}语法，一个短信里面可以设置多个变量。（模板审核耗时比较长，建议尽早提交审核），当审核完成后即可以拿到templateCode。   6.集成到项目里（maven方式演示，代码已上传github， 点击查看\r）  获取accesskey和secret 查看右上角的头像，点击Accesskey管理，去生成key和秘钥（秘钥只生成一次，要妥善保存好）。此处还可以使用子账号的accessKey进行短信发送，但跟本次内容无关就不再详细说明。  添加maven依赖 注意版本的使用，这这里使用的是4.5.16  1\u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;aliyun-java-sdk-core\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;4.5.16\u0026lt;/version\u0026gt; 5\u0026lt;/dependency\u0026gt; 6 7\u0026lt;dependency\u0026gt; 8\t\u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; 9\t\u0026lt;artifactId\u0026gt;aliyun-java-sdk-dysmsapi\u0026lt;/artifactId\u0026gt; 10\t\u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; 11\u0026lt;/dependency\u0026gt;  测试发送代码（springboot结合)  1@Value(\u0026#34;${signName}\u0026#34;) 2private String signName; 3 4@Value(\u0026#34;${templateCode}\u0026#34;) 5private String templateCode; 6 7@Value(\u0026#34;${accessKey}\u0026#34;) 8private String accessKey; 9 10@Value(\u0026#34;${accesssSecret}\u0026#34;) 11private String accesssSecret; 12 13 /** 14 * 发送验证码逻辑 15 */ 16private Map\u0026lt;String,String\u0026gt; sendSms(String mobile) throws ClientException { 17 18 Map\u0026lt;String,String\u0026gt; resultMap = new HashMap\u0026lt;\u0026gt;(); 19 20 //可自助调整超时时间 21 System.setProperty(\u0026#34;sun.net.client.defaultConnectTimeout\u0026#34;, \u0026#34;10000\u0026#34;); 22 System.setProperty(\u0026#34;sun.net.client.defaultReadTimeout\u0026#34;, \u0026#34;10000\u0026#34;); 23 24 //初始化acsClient,暂不支持region化 25 IClientProfile profile = DefaultProfile.getProfile(\u0026#34;cn-hangzhou\u0026#34;, accessKey,accesssSecret); 26 DefaultProfile.addEndpoint(\u0026#34;cn-hangzhou\u0026#34;, \u0026#34;cn-hangzhou\u0026#34;, \u0026#34;Dysmsapi\u0026#34;, \u0026#34;dysmsapi.aliyuncs.com\u0026#34;); 27 IAcsClient acsClient = new DefaultAcsClient(profile); 28 29 //组装请求对象-具体描述见控制台-文档部分内容 30 SendSmsRequest request = new SendSmsRequest(); 31 //必填:待发送手机号 32 request.setPhoneNumbers(mobile); 33 //必填:短信签名-可在短信控制台中找到 34 request.setSignName(signName); 35 request.setTemplateCode(templateCode); 36 37 int rand_num = (int)((Math.random()*9+1)*100000); 38 39 request.setTemplateParam(\u0026#34;{\\\u0026#34;code\\\u0026#34;:\\\u0026#34;\u0026#34;+rand_num+\u0026#34;\\\u0026#34;}\u0026#34;);//此处最好使用转json工具 40 41 //hint 此处可能会抛出异常，注意catch 42 SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); 43 String code = sendSmsResponse.getCode(); 44 if(code.equals(\u0026#34;OK\u0026#34;)){ 45 resultMap.put(\u0026#34;code\u0026#34;,\u0026#34;1000\u0026#34;); 46 resultMap.put(\u0026#34;msg\u0026#34;,\u0026#34;发送成功\u0026#34;); 47 }else{ 48 resultMap.put(\u0026#34;code\u0026#34;,\u0026#34;-1000\u0026#34;); 49 resultMap.put(\u0026#34;msg\u0026#34;,\u0026#34;发送失败\u0026#34;); 50 } 51 52 return resultMap; 53 } 54 1 /** 2 * 程序的入口 3 */ 4@RequestMapping(value=\u0026#34;/sendsms\u0026#34;) 5@ResponseBody 6public Map\u0026lt;String,String\u0026gt; getValidCode(String mobile){ 7 try { 8 return this.sendSms(mobile); 9 } catch (ClientException e) { 10 e.printStackTrace(); 11 } 12 Map\u0026lt;String,String\u0026gt; resultMap = new HashMap\u0026lt;\u0026gt;(); 13 resultMap.put(\u0026#34;code\u0026#34;,\u0026#34;-1000\u0026#34;); 14 resultMap.put(\u0026#34;msg\u0026#34;,\u0026#34;发送失败\u0026#34;); 15 return resultMap; 16}  其他API 请查看短信官方文档。点这\r  7.总结  如上就是项目结合阿里云发送短信验证码的具体实现逻辑了。我们可以结合缓存工具（如redis），实现验证码的有效期，从而进一步实现登录的业务逻辑。流程图如下：\n ","date":"2021-05-30","img":"","permalink":"/posts/app%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/","series":["Java"],"tags":["短信"],"title":"App发送短信验证码实现"},{"categories":["后端"],"content":"1，什么是双亲委派机制？  我的理解是，在java中，当类加载器需要对class文件进行加载时，会递归调用父加载器，当父加载器加载失败时，再向下递归传递进行加载，最后加载成功或失败。（感觉有点绕~）\n 2，类加载器有哪些？ 3，执行流程是怎样的？ 4，优点  1，安全加载：当加载类时，先委托父加载器加载可以避免破坏我们核心包里面的类。如我们可以项目里面建一个java.lang.String的类，但这样运行时实际找到的是Bootstrap ClassLoad加载的核心包里面的String，从而起到保护作用。 2，避免类重复加载：当父加载器已经加载了某类时，子加载器就没必要再加载一次。\n 5，打破双亲委派  创建一个类继承ClassLoader，重写loadClass()方法。 但重写的时候需要注意，核心类文件还是需要向上传递进行加载(loadClass)，只有需要自定义加载器加载的目录才直接加载(findClass);否则会出现Object类找不到异常\n 1 protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { 2 synchronized (getClassLoadingLock(name)) { 3 // First, check if the class has already been loaded 4 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); 5 if (c == null) { 6 // If still not found, then invoke findClass in order 7 // to find the class. 8 long t1 = System.nanoTime(); 9 10 //*********** 判断如果为当前需要当前加载器直接加载的目录，则不再向上传递 11 if(name.startsWith(\u0026#34;com.test\u0026#34;)){ 12 c = findClass(name); 13 }else{ 14 //否则按照向上加载，避免出现Object类未找到异常 15 c = this.getParent().loadClass(name); 16 } 17 //************* 18 19 // this is the defining class loader; record the stats 20 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); 21 sun.misc.PerfCounter.getFindClasses().increment(); 22 } 23 if (resolve) { 24 resolveClass(c); 25 } 26 return c; 27 } 28 } 1public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { 2 MyClassLoader myClassLoader = new MyClassLoader(\u0026#34;D:/test\u0026#34;); 3 Class clazz = myClassLoader.loadClass(\u0026#34;com.test.User\u0026#34;); 4 Object obj = clazz.newInstance(); 5 Method method = clazz.getDeclaredMethod(\u0026#34;study\u0026#34;); 6 method.invoke(obj,null); 7 System.out.println(clazz.getClassLoader().getClass().getName()); 8 9 } ","date":"2021-05-29","img":"","permalink":"/posts/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%AC%94%E8%AE%B0/","series":["Java"],"tags":["类加载机制"],"title":"双亲委派机制笔记"},{"categories":["后端"],"content":" 项目中一直有使用日志，以前都是面向CV编程，今天整理了下常用的两种输出方式（ConsoleAppendert和RollingRandomAccessAppender）和经常搞混的PatternLayout格式，还有Logger节点里的additivity属性，留下个笔记。\n Demo放在GitHub上，点击此处下载\r ConsoleAppender点击查看示例\r 1\u0026lt;Console name=\u0026#34;console1\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; 2 \u0026lt;PatternLayout pattern=\u0026#34;%d{yyyy-MM-dd \u0026#39;at\u0026#39; HH:mm:ss} %n\u0026#34;\u0026gt;\u0026lt;/PatternLayout\u0026gt; 3\u0026lt;/Console\u0026gt; RollingRandomAccessAppender点击查看示例\r 1\u0026lt;RollingRandomAccessFile name=\u0026#34;file1\u0026#34; fileName=\u0026#34;${fileName}/app.log\u0026#34; 2 filePattern=\u0026#34;${fileName}/$${date:yyyy-MM}/app-%d{yyyy-MM-dd}-%i.log.gz\u0026#34;\u0026gt; 3 \u0026lt;PatternLayout pattern=\u0026#34;%d{yyyy-MM-dd \u0026#39;at\u0026#39; HH:mm:ss} [%t] %-5level %l %logger{36} %msg%n\u0026#34;\u0026gt;\u0026lt;/PatternLayout\u0026gt; 4 \u0026lt;Policies\u0026gt; 5 \u0026lt;TimeBasedTriggeringPolicy interval=\u0026#34;1\u0026#34;/\u0026gt; 6 \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;10 MB\u0026#34;/\u0026gt; 7 \u0026lt;/Policies\u0026gt; 8 \u0026lt;DefaultRolloverStrategy max=\u0026#34;20\u0026#34;/\u0026gt; 9\u0026lt;/RollingRandomAccessFile\u0026gt; PatternLayout 1%d{yyyy-MM-dd \u0026#39;at\u0026#39; HH:mm:ss} 2 日期格式，跟SimpleDateFormat 的pattern类似 3 yyyy 年 4 MM 月 5 dd 日 6 HH 时 7 mm 分 8 ss 秒 9%t 线程名 10%-5level 日志的级别 11%l 输出日志发生的位置，对应的类和方法 (另：%L 只输出对应的行) 12%logger 输出日志记录的名称，一般用类全名 {n}里面表示输出名称只个节点，正负数均可，只是负数是从左边开始截掉n个，正数是从右边开始截取n个 13%msg 输出日志的内容 14%n 换行 additivity  如果additivity为真，则会向父级包查找，而不是直接查到Root节点， 如：com.test.controller.TestController2 会找到com.test，再找到Root 所以如果访问TestController2中的接口，会记录三条日志，demo里面有详细说明\n ","date":"2021-04-23","img":"","permalink":"/posts/springboot-+-log4j2-%E6%BC%94%E7%A4%BAdemo/","series":["springboot"],"tags":["log4j"],"title":"Springboot + Log4j2 演示demo"},{"categories":["后端"],"content":"使用切面记录请求参数与返回结果 因为在上月底有一次大的版本上线，而因为前期测试不足导致上线后系统不太稳定，所以才打算把这块补上。。。\n1@Aspect 2@Component 3@Order(1) //执行顺序排前 4public class RequestLogHandle { 5 6\t//标定好切点位置 7 @Pointcut(value = \u0026#34;execution(* com.test.apicode.*.controller.*.*(..))\u0026#34;) 8 public void action() { 9 } 10 11 @Around(value = \u0026#34;action()\u0026#34;) 12 public Object around(ProceedingJoinPoint point) throws Throwable { 13 // 获取当前登录的httpServeletRequest 对象 14 HttpServletRequest request = HttpServletUtil.getHttpServletRequest(); 15 String uri = request.getRequestURI(); 16 if (StringUtils.isEmpty(uri)) { 17 return point.proceed(); 18 } 19 //打印请求日志，利于查询问题 20 LinkedHashMap\u0026lt;String, String\u0026gt; mapLog = new LinkedHashMap\u0026lt;\u0026gt;(); 21 mapLog.put(\u0026#34;url\u0026#34;, request.getRequestURL().toString()); 22 mapLog.put(\u0026#34;HTTP Method\u0026#34;, request.getMethod()); 23 mapLog.put(\u0026#34;Class Method\u0026#34;, point.getSignature().getDeclaringTypeName() + \u0026#34;.\u0026#34; + point.getSignature().getName()); 24 mapLog.put(\u0026#34;IP\u0026#34;, request.getRemoteAddr()); 25 26 Object[] args = point.getArgs(); 27 Object[] arguments = new Object[args.length]; 28 for (int i = 0; i \u0026lt; args.length; i++) { 29 // ServletRequest， ServletResponse尽量不要出现在参数中 30 //MultipartFile文件上传可以使用阿里云的OSS产品，实在不行就过滤 31 if (args[i] instanceof ServletRequest 32 || args[i] instanceof ServletResponse 33 || args[i] instanceof MultipartFile) { 34 Log.info(this,\u0026#34;这个地址参数存在问题request,respoonse,file：{}\u0026#34;,uri); 35 // 跳过不能序列化的参数 36 continue; 37 } 38 arguments[i] = args[i]; 39 } 40 String paramter = \u0026#34;\u0026#34;; 41 if (arguments != null) { 42 try { 43 paramter = JSONObject.toJSONString(arguments); 44 } catch (Exception e) { 45 paramter = arguments.toString(); 46 } 47 } 48 49 boolean showArgs = Boolean.TRUE; 50 if (StringUtils.isBlank(paramter)) { 51 showArgs = Boolean.FALSE; 52 } 53 // 打印请求入参 54 if (showArgs) { 55 mapLog.put(\u0026#34;Request Args\u0026#34;, paramter); 56 } else { 57 mapLog.put(\u0026#34;Request Args\u0026#34;, \u0026#34;args is null\u0026#34;); 58 } 59 Log.info(this, \u0026#34;{}\u0026#34;, JSONObject.toJSONString(mapLog)); 60 return point.proceed(); 61 } 62 63 /** 64 * 后置通知 65 * 66 * @param point 67 * @param rvt 返回值（和returning指定的名字一样） 68 */ 69 @AfterReturning(value = \u0026#34;action()\u0026#34;, returning = \u0026#34;rvt\u0026#34;) 70 public void afterMethod(JoinPoint point, Object rvt) { 71 MethodSignature sig = (MethodSignature) point.getSignature(); 72 Method method = sig.getMethod(); 73 if (null != rvt \u0026amp;\u0026amp; null != method.getDeclaringClass()) { 74 try { 75 Log.info(this, \u0026#34;{}.{} : 返回数据：{}\u0026#34;, method.getDeclaringClass().getName(), method.getName(), JSONObject.toJSONString(rvt)); 76 } catch (Exception e) { 77 Log.info(this, e.getMessage()); 78 } 79 } 80 } 81 82} ","date":"2021-04-16","img":"","permalink":"/posts/springboot-%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2%E8%AE%B0%E5%BD%95%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","series":["springboot"],"tags":["切面"],"title":"Springboot 使用切面记录请求参数与返回结果"},{"categories":["开发工具"],"content":"网上的说明太多了，这里只是自己记一下步骤\n1,打开Settings设置\n2,找到Editor -\u0026gt; File Types，填写要忽略的文件后辍，确认保存即可\n","date":"2021-04-15","img":"","permalink":"/posts/intellij-idea-%E5%BF%BD%E7%95%A5%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6/","series":["IntelliJ IDEA"],"tags":[],"title":"IntelliJ IDEA 忽略项目文件"},{"categories":["跨域"],"content":"@TOC\r今天跟前端同事联调接口时发现一个非常奇葩的事情，我写的有些接口可以访问，有一些却提示跨域？？？，但是我自己用postman调试又没问题，为了解决这个问题我真是怄得go die，此记以作警醒。\n1，首先我确定我的nginx是做了处理的，允许跨域请求 1add_header Access-Control-Allow-Origin *; 2add_header Access-Control-Allow-Credentials true; 3add_header Access-Control-Allow-Headers \u0026#34;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With\u0026#34;; 然并L\n2，百度了一下说是有options的问题，于是就加上了这样一句代码 1if ($request_method = \u0026#39;OPTIONS\u0026#39;) { 2 return 204; 3} 继续然并L\n3，实在没办法了感觉要吸氧了，最后就只能对比以前可以访问的接口来看为啥不行了。一看不要紧，一看日志我就知道啥错了。 4，竟然是前端自己在header里面的参数写错了，我又没在ng里面配,于是我就把这个参数加到了add_header Access-Control-Allow-Headers里面，就解决了。 1add_header Access-Control-Allow-Headers \u0026#34;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With, X-TOKEN\u0026#34;; 5，总结一下： 1，联调时出了问题不要急着去自查，要先找清楚原因在哪再去处理； 2，出了问题多看日志错误，提示这么清楚竟然忽略太不应该。\n","date":"2021-04-01","img":"","permalink":"/posts/%E5%90%8C%E4%B8%80%E5%9F%9F%E5%90%8D%E5%87%BA%E7%8E%B0%E9%83%A8%E4%BB%BD%E5%9C%B0%E5%9D%80%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","series":[],"tags":[],"title":"同一域名出现部份地址跨域问题"},{"categories":["后端"],"content":"@TOC\r代码如下：\n1docker run -p 6379:6379 --name redis-test 2-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf 3-v /usr/local/docker/redis/data:/data 4-d redis redis-server /etc/redis/redis.conf 5--appendonly yes 但是始终不行，后来查原因为【redis.conf】文件里面有一个配置设置错误\n因为之前是手动安装的redis，设置了后台启动，所以使用docker进行自定义配置时就会失败，修改此处，删掉容器重新运行即可，此记。\n1daemonize no ","date":"2021-03-30","img":"","permalink":"/posts/docker%E5%AE%89%E8%A3%85redis%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/","series":["docker"],"tags":["redis"],"title":"Docker安装redis使用自定义配置，启动失败"}]